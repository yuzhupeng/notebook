

# 待学习的文章

[GDTR](https://blog.csdn.net/abc123lzf/article/details/109289567)



# 那些说过似懂非懂的话





# 段寄存器 

段寄存器分为可见的部分和不可见的部分

段寄存器可见的是16位,也就是下面这个东西

![image-20230904223336517](./img/image-20230904223336517.png)

<p style="color:#00FA9A;font-size:22px">
   也称之为段选择子,请记住这个名字,,后面会提及的
</p>


这个小小的WORD数据,就决定了很多的东西的

这个word寄存器大概的结构如下

![image-20230115122458860](img/image-20230115122458860.png)

他的成员有映射了很多的东西

后面会后面会娓娓道来 



## 简单介绍

下面是简单的说明了一下8个段寄存器是干嘛的,后面遇到会详细说

简单的了解一下即可

ES: 附加段寄存器ES（Extra Segment）指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段

CS: 代码段寄存器 （Code Segment）  存放当前正在运行的程序代码所在段的段基址

SS: 堆栈段寄存器SS（Stack Segment）指出当前堆栈的底部地址，即存放堆栈段的段基址。

DS: 数据段寄存器DS（Data Segment）指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。

FS:

GS:

LDTR: Local Description Tabel Register  局部描述符号表寄存器

TR:  指明了TSS位置和大小

---

GDTR: Global Description Tabel Register  全局描述符号表寄存器

IDTR: 指明了IDT

段和段之间是可以交叉的

比如数据段和栈段会存在一个包含的关系







## 关于他的读写

<p style="color:#FFB5C5;font-size:20px">
    先不说权限检查什么的<br>
    直接读写就对了<br>
    后面会说到相关的权限检查
</p>



### 基于mov

mov可以实现一个寄存器的读写

后面大多数情况下都是使用mov实现段寄存器的一个读写

比如后期提权什么的,需要用到这些读写

ps:对LDTR和TR的读写,用的不是mov



读取段寄存器 :只能拿着16位寄存器去读取数据

```assembly
mov ax,ES 
```

修改段寄存器 :会根据你的段选择子和一些附带的其它信息写入12字节

```assembly
mov DS,ax 
```

ps:我尝试修改FS.然后程序就直接g了,因为涉及一些权限的检查



> 基于mov指令实现属性探测

在x86下.我们可以看如下寄存器表示图.



下面的表格是直接给出的参考数据

| 寄存器名称      | 段选择子(Select) | 段属性(Attributes) | 段基址(Base) | 段长(Limit) |
| :-------------- | :--------------- | :----------------- | :----------- | :---------- |
| ES(附加扩展段)  | 0x0023           | 可读,可写          | 0x0000000    | 0xFFFFFFFF  |
| CS(代码段)      | 0x001B           | 可读,可执行        | 0x00000000   | 0xFFFFFFFF  |
| SS(堆栈段)      | 0x0023           | 可读,可写          | 0x00000000   | 0xFFFFFFFF  |
| DS(数据段)      | 0x0023           | 可读,可写          | 0x00000000   | 0xFFFFFFFF  |
| FS(分段机制)    | 0x003B           | 可读,可写          | 0x7FFDF000   | 0xFFF       |
| GS(x64下才生效) | 未使用           | 未使用             | 未使用       | 未使用      |

 

简单的检测, 是否可写

其实这里你也可以故意的去引发一些异常或者什么的

比如探测ss是否可以写

```c
int var = 0;
int main(int argc, char* argv[])
{
    __asm
    {
        mov ax,ss
        mov ds,ax
        mov dword ptr ds:[var],eax
    }
	return 0;
}
```



简单的检测Base属性 

```c
int var = 0;
 
int main(int argc, char* argv[])
{
    __asm
    {
        mov ax,fs
        mov gs,ax        //不要使用ds，否则编译不通过
        mov eax,gs:[0]   //fs.base+0
 		
        mov dwrod ptr ds:[var],eax
 		//如果BASE不存在的话,相当于mov dwrod ptr [0+0],eax,会触发一个异常
        //如果BASE存在的话,相当于mov dwrod ptr [BASE+0],eax,可能不会触发一个异常   
    }
	return 0;
}
```



检测Limit属性,其实就是Limit限制了你的寻址范围

```c
//报错，fs访问越界，证明Limit真实存在
int var = 0;
int main()
{
    __asm
    {
        mov ax,fs     
        mov gs,ax      //此处如果换成ds则会出现编译不过的问题
        mov eax,gs:[1000]  //fs的limit是FFF 但是读0x1000则越界了
        //访问的地址相当于下面的 但是DS的Limit是0xFFFFFFFF
        //mov eax,dword ptr ds:[0x7FFDF000+0x1000]
        mov dword ptr ds:[var],eax
    }
    
}
```



关于对地址的个人理解

比如说:

DS的范围是 [0,0xFFFFFFFF]

然后FS的范围是[0x00000000,0x7FFFFFFF]

于是FS的范围可能有点受限制

然后你就直接

```assembly
mov ax,fs
mov DS,ax
```

然后通过DS间接的去访问FS访问不到的地址



遇到的一些问题,这个代码运行就会出错,单步调试就不会出错,离谱

````c++
#include<stdio.h>
#include<windows.h>
//	int var = 0;
int main(int argc, char* argv[])
{
	int var = 0;
    __asm
    {
        mov ax,cs
        mov ds,ax
		mov edx,1
        mov dword ptr ds:[var],edx
    }
	printf("%d",var);
	return 0;
}
````





还有很多demo的例子,上面的例子是海哥的,一些火哥的例子之后再回顾一下

他的例子大多数是提出疑问,而不是说去证明一些上面东西,



### 基于L系列指令

L是Load的意思

```
LES,LSS,LDS,LFS,LGS
```

但是在使用的时候也有很多讲究

 

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>

int main()
{
	char buff[6];
	_asm {
		lea eax, buff;
		mov bx, ds;
		mov word ptr [eax+4], bx;
		les ecx, fword ptr [eax]
	}
	
	return 0;
}
```

fword的意思就是取出6个字节

les会把高2字节(段选择子)给es,也就是把数组最后2个字节给段选择子

低4字节给ecx

也就是说: 我们可以把一个tmp[6]的tmp[4,5]作为段选择子,然后赋值给寄存器



### sgdt/lgdt



```c++
#include<stdio.h>
#include<windows.h>
 
 
int main(int argc, char** argv)
{

	char x[16];
	__asm {
		sgdt x;
	}
	printf("%x,%x\n", *(DWORD*)&x[2], *(WORD*)x);
	//-> 4b590000,7f
	return 0;
}
```





## 段选择子

接下来,其实是我们细说段选择子这个结构了

![image-20230115122458860](img/image-20230115122458860.png)



先简单的介绍一下这些结构的名字

RPL: 请求权限

根据RPL.我们又可以引出其它东西

CPL: 当前权限

DPL:  最低可访问我的权限



然后是其它成员,比如Ti,Ti这个东西又和另外一个成员Index有关

因为Ti决定了我们要去找哪一张表

然后找到表后,取出哪一个成员就和Index有关了



所以有哪些表?

有GDTR,LDTR

这些表都是基于QWORD 的Arr数组,所以每次遍历是+8哟

关于GDTR,LDTR有什么区别,,我们以后再说

```c++
TI=0,查GDT表
TI=1,查LDT表
```

但是可以了解一下

GDTR:   Global Description Tabel Register  全局描述符号表寄存器 有2个值,GDTR表的开始位置和表的大小

LDTR: Local Description Tabel Register  局部描述符号表寄存器 有2个值,LDTR表的开始位置和表的大小

然后Index当然就是在表里面寻找成员了,但是寻找好像不是那么简单的线性寻找

复杂的后面再说



<p style="color:#FFB5C5;font-size:16px">
小tips<br>
LDT不能单独的存在,需要嵌套在GDT里面<br>
LDT可以有多个<br>
下面是一个段选择子的分解情况<br>
</p>



```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>

int main()
{
	int arrReg[] = { "GS",0x0000,"FS",0x003B,"ES",0x0023,"DS",0x0023,"CS",0x001B,"SS",0x0023 };
	int index = 0;
	int pri = 0;
	int aDT = 0;
	int i = 0;
	char* priRing[] = { "R0","R1","R2","R3" };
	char* arrDT[] = { "GDT","LDT" };
	int len = sizeof(arrReg) / sizeof(arrReg[0]) / 2;

	for (i = 0; i < len; i++)
	{
		index = arrReg[i * 2 + 1] >> 3;
		pri = arrReg[i * 2 + 1] & 0b11;//3=0000000000000011
		aDT = (arrReg[i * 2 + 1] & 0b100) >> 2;//4=0000000000000100
		printf("%s 去往:%s 索引:%d 然后请求:%s\n", arrReg[i * 2 + 0], arrDT[aDT], index, priRing[pri]);

	}
	return 0;
}
/*
GS 去往:GDT 索引:0 然后请求:R0
FS 去往:GDT 索引:7 然后请求:R3
ES 去往:GDT 索引:4 然后请求:R3
DS 去往:GDT 索引:4 然后请求:R3
CS 去往:GDT 索引:3 然后请求:R3
SS 去往:GDT 索引:4 然后请求:R3
*/
```





比如数据是	

![image-20230114154226362](img/image-20230114154226362.png)



所以它大概的结构

```c
strct
{
	2个bit位 RequestPrivilegeLevel; //请求特权级别
	1个bit位 TableIndicator; //查哪一个数组
	15个bit位 Index;//数组索引值
}
```

ps: 数组是QWORD Arr[xx]





一句话总结: 


    段选择子根据自己的信息去GDTR的查表 
    然后拿到数据,拆解数据,然后是一些段权限检查,不是索引谁,都可以直接塞到段寄存器 
    检查合格,就后往段寄存器里面赛 
    但是这里只涉及了8个字节,还差2字节,后面会介绍到 



# 段描述符号表成员



<p style="color:#FFB5C5;font-size:26px">
    遇到的很多概念,如果不理解没关系,后面会慢慢的get到,然后回来补充
</p>



段描述符, 不是指的是之前的段寄存器ES,DS,CS,也不是96位的那个完整的段寄存器

而是位于QWORD Arr[xxx]的数组成员

如下图

![image-20230904223936965](./img/image-20230904223936965.png)



段描述符号和段寄存器之间有一个映射关系,,差不多就是说,段寄存器的一些成员决定了我们要去哪个表寻找哪个成员



然后相同的一块内存可以被多个段描述符给定义

这个就想是某个API修改内存rwx权限一样,不能的段描述符,就代表了不同的权限,设置什么的







如果把8字节合并在一起的话,从低地址往高地址看

为什么看上去这么别扭..其实是一个兼容性导致的

为了向下兼容,变成了这样子

![d](img/d.png)



![d2](img/d2.png)





![image-20230907150811585](./img/image-20230907150811585.png)

积累值:

```
SDPLP: 从左到右第4个
0xf 非系统段3环数据
0x9 非系统段0环数据
0x7 系统段3环数据
0x1 系统段0环数据
```



顺便回忆一下段寄存器结构,下面要介绍

```c
struct Segment
{
    WORD Selecter;  //段选择子 ,类似于一个index的索引值,索引了一张表
    WORD Attribute; //段属性, 表示了当前段寄存器的 R W X 属性读写执行
    DWORD Base;     //基址,表示段的起点 
    DWORD limit;    //基址的长度 
}//12字节,96位
```



引入:

段描述符分为 数据段描述符,代码段描述符,系统段描述符

后面会介绍如何判断是什么段





## Base和Limit

(Base:DWORD `[0,15]+[16,23]+[24,31] `

![d](img/d.png)

Base由3部分构成(1+1+2=4)



Limit:DWORD但是,**数据是20个bit位** `[0,15]+[16,19]`

![d](img/d.png)



不是说我们只看Base和Limit就可以确定一个范围

还有就是范围 不是说就是Base[0,Limit]

这里面涉及很多东西,,,,后面再说

另外我还搞得不是很明白的



## Attribute



Attribute:WORD `[8,23]`

![d](img/d.png)

[8,23]这16位其实就对应了段寄存器结构体成员的Attribute

对于没介绍的成员,大多数是没用的,或者不知道的



### P位




```
P=1,该段描述符有效
P=0,反之无效
```

通过指令将段描述符加载至段寄存器的时候，CPU第一件事就是检查该段描述符的P位。

如果P位等于0，那么其他的检查就不做了。只有当P位为1的时候才会做后续的其他检查





### S位




段描述符分为了2大类

```
S=1 : code or data的描述符
S=0 : 系统段 描述符
```

系统段描述符可能是调用门、中断门、任务门、TSS段



### Type域 [8,11]




占据4位 ,可以形成一个16进制

下面是基于S=1的情况,引入介绍

>   `Attribute.DPL` 它占据2个bit位,要么是0b11,要么是0b00
>
>   ![image-20230114153231984](img/image-20230114153231984.png)
>
>   代码段或者数据段一定有: S=1,P=1 ,然后DPL=0b00或者0b11
>
>   P+DPl+S=4个比特位,可以形成一个16进制
>
>   所以,对于代码段或者数据段而言,这4个bit位的值要么是0x9,要么是0xF



然乎继续Attribute.Type域

下面主要介绍的是代码段和数据段的Type域, 系统段的Type域后面介绍, 



![image-20230114154033315](img/image-20230114154033315.png)



#### [11]位



ps: 32位中的第11位,不是Attribute的11位

```
[11]=1, 指明代码段
[11]=0, 数据段
```

然后,换句话说,如果Type域>7,那么就是代码段

Type域的属性会根据你是不同的段,各个属性值会有不同的意义



#### 其它3位



##### 数据段的AWE




A属性: 该段是否被访问过

W属性: 是否可写 write

E属性: 奇怪的拓展属性

---

A: 表示被访问过

W: 0是只能读, 1是可读可写

E: 0,向上拓展 ,1是向下拓展

---

>如果E=0 向上挺赞,那么有效段范围就是红色的 左图
>
>如果E=1,向下拓展,那么有效段范围就是红色的 右图
>
>![image-20230114155523014](img/image-20230114155523014.png)



##### 代码段的AWC

1.   A属性: 该段是否被访问过
2.   W属性: 是否可读 read
3.   C属性: 
     1.   为1表示一致代码段 只能 低访问高, 高不能访问低, 自下而上访问 ,但是本质的身份还是低,只是说可以访问高
     2.   为0表示非一致代码段   只能 低访问低, 高访问高, 互不干扰



一般情况下,我们的C位都是0, C=1的都是恶意构造的





在下节`代码跨段`时还会再讲诉

这里贴一个系统段的Type域说明.不做讲解

![image-20230114162402181](img/image-20230114162402181.png)



`<8` 都是16位的

`>8` 的都是32位



##### 小实验



首先写一个简单的exe,拖进xdbg

![image-20230905220223205](./img/image-20230905220223205.png)

发现是CS: -> 0b11011

RPL: 0b11,强求权限是3

TI: 0 去GDT表索引

index: 0b11 , 索引值是3

所以目标的段描述符号

![image-20230905220623858](./img/image-20230905220623858.png)

有也就是`00cf9300-0000ffff`

然后在空白位置8003f000写入

```c++
eq 8003f000 00cf9700`0000ffff
//00cf9300`0000ffff -> 00cf9700`0000ffff 
```

然后

![image-20230905221129027](./img/image-20230905221129027.png)

然后就是g

```c++
#include<stdio.h>

int main()
{
	int value=0;
	printf("Hello\n");
	__asm{
		mov ax,0x93;
		mov ss,ax
		mov ebx,0x20
		mov dword ptr ds:[value],ebx;
	}
	printf("%d",value);
	return 0;
}
```

不知道为什么,,ss的写入,或者ds的写入,,,他都异常,,,,

下`



### DB位



感觉的话,D位是用于16位CPU和3位CPU过度的一个属性位


位于高4字节的22位

![image-20230115094724085](img/image-20230115094724085.png)



数据段用B去描述

代码段用D去描述



DB位会对3种产生影响

<p style="color:#FFB5C5;font-size:16px">
    对CS段的影响：
</p>


D = 1，采用32位寻址方式。这是x86默认的寻址方式

D = 0，采用16位寻址方式。

<div style="color:#00CED1;font-size:16px">
	硬编码指令前缀67：改变寻址方式。<br>
</div>


```
MOV DWORD PTR SS:[EBP-0x18], ESP //32位寻址
MOV DWORD PTR DS:[DI-0x18], ESP //加了67的前缀的16位寻址方式
```



比如32位模式下,,使用一些和16位相关的操作数什么的,要加前缀

就是因为这个D位..而32的的操作数却不需要加前缀,,,那时因为这个是默认的



<p style="color:#FFB5C5;font-size:16px">
    对SS段的影响：
</p>


D = 1，隐式对栈访问指令（会修改ESP，如：PUSH、POP、CALL）使修改ESP

D = 0，隐式对栈访问指令（会修改SP，如：PUSH、POP、CALL）修改SP



<p style="color:#FFB5C5;font-size:16px">
    对向下扩展的数据段的影响：
</p>


D = 1，段上限为4GB。

D = 0，段上限为64KB。

![image-20230115101919954](img/image-20230115101919954.png)

其实D干的事情,就是限制段的Limit吧.个人呢理解

以前寻址最大时0xFFFFFFFF,现在变为了64k的寻址范围



### G位




Limit在取数据的时候,然后是20位,一般都是0xFFFFF,

但是我们知道段的最大长度,但是可以是0xFFFFFFFF

那是如何实现的?

依靠G位

```
G位=1,最大长度0xFFFFFFF
G位=0,最大长度是0xFFFFF
```





比如Base=10, Limit=20

当G=0,然后范围是10,20

当G=1.然后范围是10,20+1x0x1000



Base=0xffff0000,Limit=0x1000,G=0

如果Base>Limit,用Base+Limit作为基址

当然还需要很多例子来帮助理解





### DPL

你用什么权限来访问我



关于RPL,DPL,CLP的权限检查

之后可以看看这个文章

https://www.cnblogs.com/chenwb89/p/operating_system_004.html

https://blog.csdn.net/better0332/article/details/3416749



```
mov DS,AX
```

AX中是一个16位的数，又称为段选择子，

段选择子中包含了一个索引，可以通过该索引找到段描述符。

并不是说段描述符指向谁，就一定会将这个段描述符加载到当前的段寄存器中。

它在加载之前，会有一系列的检查，比如有没有权限，允不允许把段描述符加载到段寄存器中。

如果想要了解检查的细节，还要了解一些其他概念



<p style="color:#FFA500;font-size:24px">
    CPU分级:
</p>



![image-20230115102828976](img/image-20230115102828976.png)

为什么要分级？

1.  因为对CPU来说，有些特权指令是只有在0环(Ring 0)才可以使用的。
2.  Windows系统只使用了CPU中的两个环，R0和R3。

0环的地址好像是0x80000000~0xFFFFFFFF







RPL <=CPL,	CPL<=DPL



<p style="color:#FFA500;font-size:24px">
    引入介绍CPL:
</p>

大名:Current Privilege Level 当前特权级别，

在CS和SS中储存的段选择子后2位。 然后CS和SS处于的环级别是一致相同的

CS什么权限,SS就是什么权限,如果不相同,

也就是说,要想知道当前程序处于什么环,就去看SS/CS的CPL位

就之前,我们对段选择子的定义是

![image-20230115103244445](img/image-20230115103244445.png)

但是对于CS,SS,它的那个最后2位,不叫RPL,叫CPL 

比如

```
CS:0023 = 0b100011 CPL=0b11=2
SS:002B = 0b101011 CPL=0b11=3
```

所以就可以看出,是三环?应该把



<p style="color:#FFA500;font-size:24px">
    开始DPL:
</p>

大名 :Descriptor Privilege Level,描述符特权级别。

通俗的理解：

如果你想访问我，那么你应该要具备什么特权。如果权限存在越级访问,是不允许的

因为Windows中只使用了0环和3环。所以在Windows中，DPL只会是00或者11

eg:

引入:

AX是段选择子,含有成员RPL(希望请求的权限)

AX指向的段,含有成员DPL(GFTR[index]该段的权限)

该指令处于CS,CS和SS还有CPL(当前环境的权限)

```
MOV DS, AX//将AX指向的段描述符加载至DS段寄存器。
//如果AX指向的段DPL(描述符特权级别) = 0，
//但当前程序的CPL(当前进程特权级别) = 3，
//这行指令(MOV DS, AX)是不会成功的，因为段权限检查无法通过。
```



<p style="color:#FFA500;font-size:24px">
    引入RPL:
</p>

大名: Request Privilege Level,请求特权级别

![image-20230115122458860](img/image-20230115122458860.png)

-   RPL是段选择子的成员，每个段的段选择子都有自己的RPL。
-   RPL就是一个数值，意味着你可以随便写[0,3]，RPL可以随意指定。
-   但DPL不同，每个段描述符只有唯一的DPL。



<p style="color:#FFA500;font-size:24px">
    数据段权限如何检查:
</p>



下面以数据段检查为例,其它段检查会不同,后面会介绍,[点击我就跳转]()



比如当前程序处于0环，也就是说CPL = 0。

```
											//CPL=0
MOV AX, 000B      //0000 0000 0000 1011，	 RPL = 3
MOV DS, AX        //AX指向的段描述符的			DPL = 0
```

数据段的权限检查依据

-   CPL <= DPL 且 RPL <= DPL (数值上的比较)
-   只有CPL与RPL都要小于等于DPL的时候，上面的两行指令才能加载成功，否则会失败

也就是当前权限CPL和请求权限RPL都得大于索引成员的权限DPL(向下访问,不能越级访问)





关于为什么有3个权限,2个不香吗?

<div style="color:#FFB5C5;font-size:16px">
    例如写代码时， <br>
    可以使用 "读写" 的权限去打开一个文件，
    但是为了避免出错， <br>
    有些时候我只想使用我能够得到的权限中的部分权限, <br> 
    比如我请求 "只读" 的权限去打开一个文件。可能我原本的可以获取所有权限 <br>
</div>



小结:

<div style="color:#00CED1;font-size:16px">
    CPL(Current Privilege Level)：当前进程特权级别。（CS和SS中储存的段选择子后2位。）<br>
	DPL(Descriptor Privilege Level)：描述符特权级别。（如果想访问，应该具备什么样的权限。） <br>
	RPL(Request Privilege Level)：请求特权级别。（使用什么样的权限去访问。<br>
</div>


# 段权限检查



这个东西主要是抓住本质...

次要的东西就是根据本质特征

然后慢慢的去推导



1), CPL

CPL是对CS的RPL的一种别称

所以CPL=CS.RPL



2), RPL

RPL是段选择子的成员

RPL的意思一个对段访问的请求权限啊,,这个权限的作用不是特别大

另外不是说你申请了某个访问权限,别人就一定给你对应的访问权限



3), DPL

这个权限,,以段的角度来说,,就是你要访问我,,最低应该具备的权限

也可能是说你访问我应该具备的权限吧..目前理解得不是很到位



在正常情况下,,CPL=DPL,然后不关注RPL

在权限角度 , min(CPL,RPL)=DPL



然后CS和SS在权限上要保持一直

<p style="color:#FFB5C5;font-size:16px">
    CS.DPL==CS.RPL==SS.DPL==SS.RPL
</p>






权限角度: CS的CPL>= 目标的RPL, 目标的RPL>目标的DPL

同时,CS的CPL>=CS的DPL

CS的CPL>=DS的RPL,DS的RPL>=DS的DPL,所以CS的CPL>=DS的DPL





接下来又说说 一致代码段和非一致代码段,,在权限上有什么特点

> 非一致代码段: 

CPL==DPL,RPL>=DPL (权限上)

为什么?

首先RPL就是一个小丑,,所以权限卡得不是很严.RPL>=DPL就行

然后非一致代码段是 不同级别的权限各自访问各自的,,所以就是CPL=DPL,而不会存在CPL在权限上高于DPL或者什么之类的



> 一致代码段:

 CPL<=DPL  (权限上)

为什么?

因为一致代码段 只能低权限越级访问高权限

所以存在CPL权限低于目标段的DPL

# 初入代码跨段

为什么说是初入?

因为这里面涉及很多东西,,所以就简单的介绍一下,,,细节会单独提出来的



分为很多情况的

比如`JMP FAR`

比如 `CALL FWORD PTR`



期间涉及线程环境的切换

可以实现代码跨段的指令,期间可能会修改CS:IP,甚至SS:SP

```
jmp far
call far
int
retf
iret(16位)
ireted(32位)
//这些指令有什么区别,那是后面会讲到的
```

然后还能够修改CS,IP的 ->sysentry,sysexit,



段,我感觉应该是一种环境,,比如我代码跨段

前往的虚拟地址甚至可以是一样的,,,但是线程环境不再是一样的

就想是`CALL FWORD PTR`不提权,去往附件的地方



段间跳转分为两种情况：

1.  要跳转的段是一致代码段 ,存在跨级访问
2.  要跳转的段是非一致代码段,各自调用各自的

但是我们通常使用的是`非一致代码段`的跨段,因为那样更加方便,不容易出错吧



> 最后引出一个小结论,是通过前人总结的

jmp,call是可以用来提权的

但是 jmp,call, 不调用`门`,或者不调用`TSS`,只能在同级之间跳转

retf,iretd呢,只能在同级之间跳转,或者只能降级跳转



<div  style="color:#FFB5C5;font-size:16px">
    注意：直接对代码段进行JMP 或者 CALL的操作，<br>
	无论目标是一致代码段还是非一致代码段，CPL当前权限都不会发生改变.<br>
    如果要提升CPL的权限，只能通过调用门<br>
</div>



## JMP FAR 段间跳转

jmp的跳转不涉及栈的变化...? 可能吧



### 不提权的JMP



```
JMP x:y
机器码是
EA 34124000(y) 2000(x)
```

该指令要提供6字节的参数(2+4)==(段选择子+偏移)



对于这种,是修改CS:IP的

但不会修改SS:SP

`JMP x:y`的y就是去往目标地方的偏移

比如x=0x004B,Y=0x0040101A



关于一些权限检查之类的,,我想通过后面的一些驱动演示,,拿到0环的权限才方便做一些实验

比如严重 CPL>=DPL才可以跳转成功

但是目前的CPL,我们只有R3的,,,R0的暂时拿不到









#### 实验1 



```
gdtr=8003f000
0: kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff //[0],[1]
8003f010  00cf9300`0000ffff 00cffb00`0000ffff //[2],[3]
8003f020  00cff300`0000ffff 80008b04`200020ab //[4],[5]
8003f030  ffc093df`f0000001 0040f300`00000fff //[6],[7]
8003f040  0000f200`0400ffff 00000000`00000000 //[8],[9]
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

首先CS=0x001B

```
CS 去往:GDT 索引:3 然后请求:R3
```

索引的值是[3]=00cffb00`0000ffff

于是我们为了突出效果,在[9]:8003f048的地方插入值00cffb00`0000ffff

```
0: kd> eq 8003f048 00cffb00`0000ffff
0: kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cffb00`0000ffff //发生改变
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
0: kd> g
```



打算跳往的选择子是0x004B

```
0x004B: 去往:GDT 索引:9 然后请求:R3
```

然后后续我么直接跳到main函数罢了

```
JMP FAR 0x004B:0x00401010 //0x00401010函数地址
```

跳转前

![image-20230126202425362](img/image-20230126202425362.png)

跳转后

![image-20230126202717833](img/image-20230126202717833.png)



如果我们跳往的不是CS段,而是DPL为ring0的段

```
0: kd> eq 8003f048 00cf9b00`0000ffff
0: kd> g
```

 00cf9b00`0000ffff 段范围:00000000[FFFFFFFF] ,段类型:非系统段 段权限:R0

于是我们尝试从非非一致代码段,从R3 JMP FAR 到R0

直接触发异常

![image-20230126210321859](img/image-20230126210321859.png)



#### 实验2 



是一个一致代码段的实验

通过call far实现了R3调用R0

同时他还需要修改页的一些东西

这个可以参考

```c++
\火哥内核1-\保护模式\09.段跳转流程;
\火哥内核1-\保护模式\10.段跳转实验-一致代码段分析
```

但是没看懂的



#### 实验3



##### 情景1



很简单的一个实验

我们把CS的段选择子挪到一个地方去

CS:0x1B,CPL是3环

0x48是cv了CS的段选择子,但是0x48的RPL=0环

```c++
kd> dq gdtr
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cffb00`0000ffff
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

然后尝试去跳转, 可能猜测会失败

因为CPL=目标DPL=3环,目标段选择子是0环的RPL



发现跳转成功

![image-20230909193847995](./img/image-20230909193847995.png)

但是CS!=0x48,而是等于0x4B...为什么?

![image-20230909194308657](./img/image-20230909194308657.png)



当访问的RPL=0, 同时CPL=目标DPL,

如果JMP成功,会强行把最后的CPL该为目标DPL权限

所以

```c++
In [8]: bin(0x4b)
Out[8]: '0b1001011'

In [9]: bin(0x48)
Out[9]: '0b1001000'
```



如果CPL=0,目标RPL=3,目标DPL=0

那么最后的RPL会被强行转化为0

另外.RPL是请求权限,不是一定要给你

真正比较的是CPL和DPL



##### 情景2

重复之前的操作

如果CPL=3, 目标DPL=0,目标RPL=0

去jmp就会出现异常

![image-20230909200811315](./img/image-20230909200811315.png)

ps: 之前的跳转CPL=3, 目标DPL=3,目标RPL=0是正常的



##### 情景3(不明白)

重复之前的操作

如果CPL=3, 目标DPL=0,目标RPL=0

但是我们用的是一致代码段

一致代码段就是可以 低级别越权访问

```c++
|         (00cf9f00`0000ffff)
|         (00000000)[0,000FFFFF)        |
|---------------------------------------|
| TYPE | S | DPL | P | AVL | - | DB | G |
| 1111 | 1 | 00  | 1 | 0   | 0 | 1  | 1 |
|---------------------------------------|
```



然后查看

```c++
kd> eq 8003f048 00cf9f00`0000ffff
kd> dq gdtr
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cf9f00`0000ffff
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

再跳一下看看

发现可以跳转成功

![image-20230909202138395](./img/image-20230909202138395.png)



但是呢

CPL=3,DPL=0,RPL=0

但是最后,依然CPL=3

没有实现一个CPL=0



如果我们一开始是

CPL=3,RPL=3,DPL=0呢

就会出现异常...呵呵

之前好像说,,权限至少得是DPL之上,,所以这是异常的原因还是什么???

不太明白









##### 情节4

这个就是用的call

CPL=3, 目标DPL=0,目标RPL=0

看是否可以成功的call

```c++
0: kd> eq 8003f048 00cf9b00`0000ffff
|         (00cf9b00`0000ffff)
|         (00000000)[0,000FFFFF)        |
|---------------------------------------|
| TYPE | S | DPL | P | AVL | - | DB | G |
| 1101 | 1 | 00  | 1 | 0   | 0 | 1  | 1 |
|---------------------------------------|
```



CPL=3,DPL=0,RPL=0

发现跳转失败

![image-20230909203217264](./img/image-20230909203217264.png)

说明什么,,在CPL=3,DPL=0,RPL=0的情况下,,,使用call,也失败

call在不调用门,TSS的情况下,,仍然不能提权,,只能在同一级别之间跳转



```c++
#include<stdio.h>
void test(){
	printf("hi you get me\n");
	return ;
}
int main()
{
	char buf[]={0,0,0,0,0x48,0};
	*(int*)buf=(int)test;
	__asm{
		call fword ptr ds:[buf];
	}
	return 0;
}
```



然后我们尝试在同一级别之间call

```c++
0: kd> eq 8003f048 00cffb00`0000ffff;
|         (00cffb00`0000ffff)
|         (00000000)[0,000FFFFF)        |
|---------------------------------------|
| TYPE | S | DPL | P | AVL | - | DB | G |
| 1101 | 1 | 11  | 1 | 0   | 0 | 1  | 1 |
|---------------------------------------|
```



CPL=3,DPL=3,RPL=0;

可以看见就成功跳转过去了

但是还是会遇到一些问题

比如在test下断点,就g了

![image-20230909205121014](./img/image-20230909205121014.png)



在没有call进去时

![image-20230909211127072](./img/image-20230909211127072.png)

call进去后

![image-20230909211235311](./img/image-20230909211235311.png)



尝试使用retf正常返回



```c++
0: kd> dq gdtr
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
0: kd> eq 8003f048  00cffb00`0000ffff

```



```c++
#include<stdio.h>
int gvar=10;
void _declspec(naked) test()
{
	__asm{
		push eax;
		push ecx;
		lea eax,gvar;
		xor ecx,ecx;
		mov [eax],ecx;
		pop ecx;
		pop eax;
		retf;
	}
}
int main()
{
	char buf[]={0,0,0,0,0x48,0};
	*(int*)buf=(int)test;
	printf("hi i am hello world\n");
	printf("%08X\n",gvar);
	__asm{
		call fword ptr ds:[buf];
	}
	printf("%08X\n",gvar);
	return 0;
}
```



执行如下

![image-20230909214119877](./img/image-20230909214119877.png)



### 提权的JMP

略,,后面说吧





## CALL FAR 段间调用(调用门引入)

不同于之前的call

现在的call far不仅仅是push ip了



retf会pop多少个空间,这取决于你的call是否提权

比如你提供的目标段选择子,

如果不提权的话,,,retf就pop两个东西

是门,且提权的话,retf就pop4个东西



也可以说,retf降权的时候,返回4个

retfz在同级之间,返回2个







### 不提权

指令格式：CALL XX:EIP(EIP是废弃的), 

并不使用后面的EIP，EIP是被废弃的。而真正跳往的地址是XX提供的

XX是一个段选择子，通过段选择子去查询GDT表找一个段描述符，且该段描述符必须是调用门的段描述符。 

因为我们要去的地方是一个特殊的调用门,调用门里面有那个CALL后的实际地址

通过调用门我们还可以提升 CPL 的权限

执行的时候,我们是先PUSH CS,然后PSUH IP

```
EIP
CS
```



### 提权

指令格式：CALL XX:EIP(EIP是废弃的)

跨段调用时，一旦有权限切换，伴随着以一个新的堆栈出现。

CS的权限一旦改变，SS的权限也要随着改变，即CS与SS的等级必须一样。

新的堆栈里面,初步的值会是下面的样子

```
栈顶:	   EIP //返回的地址
		CS //以前的cs
		ESP //以前的栈顶
		SS //以前的ss
```

新的堆栈来源于参见TSS段

后面会讲到关于CALL的提权



### 实验





```c++
0: kd> eq 8003f048 0040ec00`00081005
```





![image-20230909220833069](./img/image-20230909220833069.png)

运行后





# 调用门

Windows系统没有再使用调用门，但是使用了中断门

学习调用门是为了更好地理解中断门 后续讲解中断门

回顾: 

1.   长调用,CALL XX:YYYY
2.   以前的段描述符



![image-20230114111543887](img/d2.png)

3.   系统段的TYPE域

     ![image-20230114162402181](img/image-20230114162402181.png)

华丽的分割线

```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>

int main()
{
	long long arrGDT[] =
	{
		0x0040ec0000081020
	};
	char* Seginfo[] = { "  系统段","非系统段" };
	char* priRing[] = { "R0","R1","R2","R3" };
	int len = 0;
	int tmp = 0;
	int i = 0;
	int SegSlector = 0;
	int Deip = 0;
	len = sizeof(arrGDT) / sizeof(arrGDT[0]);
	for (i = 0; i < len; i++)
	{
		tmp = (arrGDT[i] & 0x0000F00000000000) >> 32 >> 12;
		SegSlector = (arrGDT[i] & 0x00000000FFFF0000) >> 16;
		Deip = (arrGDT[i] & 0xFFFF000000000000) >> 32 | arrGDT[i] & 0x000000000000FFFF;
		printf("段选择子:%d,去往的EIP:%08X,该调用门权限:%s,属于%s\n", SegSlector, Deip, priRing[(tmp & 0b0110) >> 1], Seginfo[tmp & 0b0001]);
	}
	return 0;
}
```



## 无参

Windows中并没有使用调用门，所以需要手动构造一个调用门。

然后调用门也有段描述符,也存在于GDTR表中,下面就是调用门专用的描述符定义

![image-20230116112752054](img/image-20230116112752054.png)

S位指明了是系统段

Offset in Segment: 指明了前往的EIP(弥补了之前无效的EIP)

SegmentSelector:  指明了前往的段寄存器(一个新的段选择子)

Type域`1 1 0 0`指明了是一个32位的调用门

所以对于一个调用门的,段描述符固定的部分是有

S=0

Typ=1100

所以,我们通过要构造一个调用门的话(8字节构造)

```c
---高位地址
Offset in Segment 31:16 = 0x0000		//暂定
					  P = 1	
					DPL = 二进制:11		//该段的权限,不太理解
					S	= 0
				   TYPE	= 二进制:1100
			Param.Count = 二进制:00000		//几个参数
	   Segment Selector = 0x0008		//段选择子
Offset in Segment 15:00 = 0x0000		//暂定
--- 地位地址
```



下面是一个通过调用门提权的操作

然后因为我没有环境,就写了一些自己的理解在代码注释里面

```c
#include <windows.h>
#include <stdio.h>
char Hello[]="Hello World\n";
void __declspec(naked) enHancePrivilege()
{
    
    __asm
    {
 /*
        push ebp
        mov ebp,esp
        sub esp,16
        lea eax,Hello
        push eax
        call eax
        add esp,4
        pop ebp
        mov esp,ebp
        pop ebp
 */
        retf        //注意返回, 不能是ret!
    }
}

int main()
{
    char buff[6];

    *(DWORD*)&buff[0] = 0x00000000; //可以随便写, 这个就是EIP, EIP是废弃的
    *(WORD*)&buff[4] = 0x48;        //不能随便写,涉及了索引值和RPL 通过它寻找调用门的描述符.
    //而调用门的段描述符涉及了最后前往的XX:EIP

    __asm
    {
        call fword ptr[buff]        //长调用
    }

    getchar();

    return 0;
}
```



```
0: kd> eq 8003f048 0040EC0000081020
0: kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 0040ec00`00081020
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

首先代码运行到call far的时候,程序会终止到windbg的0环调试器

```
Single step exception - code 80000004 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
00401020 55              push    ebp

```



当我们进入调用前

![image-20230126233743685](img/image-20230126233743685.png)

进入调用后,出现在windbg调试器

```
0: kd> r esp
esp=ee9badd0 //新的栈
0: kd> dd ee9badd0
ee9badd0  	0040de39 //返回的EIP
            0000001b //以前的CS
            0012ff28 //以前的ESP
            00000023 //以前的CS
ee9bade0  	805470de 
            f7353b85 
            85f187e0 
            00000000
ee9badf0  	...

```





然后是一个通过提权后,读取高2G内存搞事的代码 

```c

#include <windows.h>
 
BYTE GDT[6] = {0};
DWORD dwH2GValue;
 
void __declspec(naked) GetRegister()
{
    __asm
    {
        pushad
        pushfd
 
        mov eax,0x8003f00c    //读取高2G内存
        mov ebx,[eax]
        mov dwH2GValue,ebx
        sgdt GDT;             //读取GDT
 
        popfd
        popad
 
        retf                  //注意返回, 不能是ret
    }
}
 
void PrintRegister()
{
    DWORD GDT_ADDR = *(PDWORD)(&GDT[2]);
    WORD GDT_LIMIT = *(PWORD)(&GDT[0]);
 
    printf("%x %x %x\n", dwH2GValue,GDT_ADDR,GDT_LIMIT);
}
 
int main()
{
    char buff[6];
    __asm
    {
        mov ebx,ebx
        mov ebx,ebx
    }
 
    *(DWORD*)&buff[0] = 0;
    *(WORD*)&buff[4] = 0x48;//CS 去往:GDT 索引:9 然后请求:R0
 
    
    //调用门:0040ec00`00081020
    __asm
    {
        call fword ptr[buff]//进入调用门
    }
 
    PrintRegister();
 
    getchar();
 
    return 0;
}
```

运行结果

![image-20230126231814236](img/image-20230126231814236.png)



后面,海东老师讲到

读取GDTR的指令`SGDT`在ring3也可以正常使用

于是我自己跑了一下

```c
#include <windows.h>
#include<stdio.h>
BYTE GDT[6] = { 0 };

void __declspec(naked) GetRegister()
{
    __asm
    {
        sgdt GDT;
        ret        
    }
}

void PrintRegister()
{
    DWORD GDT_ADDR = *(PDWORD)(&GDT[2]);
    WORD GDT_LIMIT = *(PWORD)(&GDT[0]);

    printf("%x %x\n",GDT_ADDR, GDT_LIMIT);
}

int main()
{
    GetRegister();
    PrintRegister();
    return 0;
}
```

输出

```
4b590000 7f
```

啊这...好像不太对

但是,这个指令有个神奇的效果(程序调试的时候,莫名其妙的跑飞)



## 有参

其实也就说设置一下参数个数,然后再push

调用门配置

```
---高位地址
Offset in Segment 31:16 = 0x0000		// 暂定
					  P = 1
					DPL = 二进制:11
					S	= 0
				TYPE	= 二进制:1100
			Param.Count = 二进制:00011	// 注意变化！
	   Segment Selector = 0x0008
Offset in Segment 15:00 = 0x0000		// 暂定
--- 地位地址
```



代码

```c
#include <windows.h>

DWORD x;
DWORD y;
DWORD z;

void __declspec(naked) CateProc()
{
	__asm
	{
		pushad //依次将EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI，执行后ESP- 32
		pushfd //之后后ESP-4
		//此刻堆栈已经有新的36个字节的数据0x24
            
		mov eax,[esp+0x24+8+8]
		mov dword ptr ds:[x],eax
		mov eax,[esp+0x24+8+4]
		mov dword ptr ds:[y],eax
		mov eax,[esp+0x24+8+0]
		mov dword ptr ds:[z],eax

		popfd
		popad

		retf 0xC			// 注意堆栈平衡 写错蓝屏
	}
}

void PrintRegister()
{
	printf("%x %x %x \n", x, y, z);
}

int main(int argc, char* argv[])
{
	char buff[6];
	*(DWORD*)&buff[0] = 0x12345678;
	*(WORD*)&buff[4] = 0x48;
	__asm
	{
		push 1					// 参数1
		push 2					// 参数2
		push 3					// 参数3
		call fword ptr[buff] 	// 压入SS ESP CS IP 这里依次压入16 32 16 32 所以
	}
	PrintRegister();
	getchar();
	return 0;
}

```



关于堆栈图,

![image-20230116211228646](img/image-20230116211228646.png)

所以,就是为什么会有

```
mov eax,[esp+0x24+8+8]
mov eax,[esp+0x24+8+4]
mov eax,[esp+0x24+8+0]
```

疑惑来了...说好的新的堆栈呢? 这不就是以前的堆栈继续用? 还是说我分析错了



# IDT表

ps: 反正学的挺懵的

<div  style="color:#FFB5C5;font-size:16px">
    引入<br>
	系统调用：<br>
    当在开发应用层程序的时候，使用的API在执行过程中通过3环进入0环，这个过程就是系统调用<br>
    而从3环是如何进入0环的过程，就使用到了中断门。需要注意的是，老的CPU是通过中断门进入的0环，而现在的CPU都是通过快速调用。<br>
	调试:<br>
    例如OD使用F2下断点，下断点其实就是把某个字节修改为了0xCC，0xCC硬编码对应的汇编指令就是INT3，INT3就是用来执行中断门的。<br>
</div>

IDT表在哪里?

IDTR寄存器会告诉你

IDT表存储了中断描述符表 ,它同 GDT 一样，每个元素占 8 个字节

仅在xp环境有效

```
r idtr //查看IDT表其实地址
r idtl //查看IDT长度
```



IDT表可以包含3种门描述符：

1.  任务门描述符。
2.  中断门描述符。
3.  陷阱门描述符。





## 中断门



TYPE域说明了是一个32位中断门

中断门不允许传递参数，所以Parame Count都是0。

![img](img/interrupt.png)



构造中断门

```
Offset in Segment 31:16 = 0x0000		//暂定
					  P = 1
					DPL = 二进制:11
					S 	= 0
				TYPE	= 二进制:1110
	   Segment Selector = 0x0008
Offset in Segment 15:00 = 0x0000		//暂定

```

然后把中断门写入IDT

```c
#include <windows.h>
#include<stdio.h>

DWORD dwH2GValue;

void __declspec(naked) GetH2GValue()
{
	__asm
	{
		pushad
		pushfd

		mov eax, [0x8003f00c]
		mov ebx, [eax]				// 获取高2G地址的值
		mov dwH2GValue, ebx

		popfd
		popad

		iretd
	}
}

void PrintH2GValue()
{
	printf("%x \n", dwH2GValue);
}

int main(int argc, char* argv[])
{
	__asm
	{
		int 0x20			// 中断门位置在IDT[20]
	}

	PrintH2GValue();

	getchar();
	return 0;
}

```



## 陷阱门





![image-20230116214705995](img/image-20230116214705995.png)



陷阱门,TYPE域是1111

触发一个陷阱门,比如`int 0x20`



<p id="Attribute.DPL" style="color:#00FA9A;font-size:16px">
    陷阱门与中断门的区别
</p>

中断门执行时，会将IF位清零，但陷阱门不会。如果IF位为0，意味着不再接收可屏蔽中断。

IF位：eflag寄存器下标为9的位置。

中断分为

-   可屏蔽中断、
-   不可屏蔽中断。



是在硬件上的概念。

<p style="color:#FFA500;font-size:16px">
    可屏蔽中断(也就是可以去屏蔽的中断,可以选择屏蔽或者不屏蔽)
</p>

说明时候是发生外界中断? 比如你按下键盘,点击鼠标,这些就是外界硬件发送额中断请求

IF=1,CPU接受你的终中断请求

IF=0，CPU就会当作无事发生。屏蔽你的中断请求

<p style="color:#FFA500;font-size:16px">
    不可屏蔽中断(也就是怎么都无法屏蔽的中断)
</p>

如计算机正在运行，忽然断电了。断电时，电源管理器会向CPU发送请求，

其不受IF位影响，就是不可屏蔽中断。

IF位不管为1还是0，CPU都必须马上去处理。

主板上有电容/电源，当断电的一刹那，可以保证CPU完成一些清理工作。



## 任务段

在调用门、中断门与陷阱门中，一旦出现权限切换，那么就会有堆栈的切换；

而且，由于CS的CPL发生改变，也导致了SS也必须要切换

思考：切换时，会有新的ESP和SS(CS是由中断门或者调用门指定)这2个值从哪里来的呢？

答案：TSS (Task-state segment )：任务状态段 

>   引入

TSS在哪里?

TR寄存器会告诉你

TSS是一块内存

大小：104字节

TSS存储了一堆寄存器的值

这很重要



![img](img/taskgate.png)



把图片抽象出来就睡

```c
typedef struct TSS {
    DWORD link; // 保存前一个 TSS 段选择子，使用 call 指令切换寄存器的时候由CPU填写。
    // 这 6 个值是固定不变的，用于提权，CPU 切换栈的时候用
    DWORD esp0; // 保存 0 环栈指针
    DWORD ss0;  // 保存 0 环栈段选择子
    DWORD esp1; // 保存 1 环栈指针
    DWORD ss1;  // 保存 1 环栈段选择子
    DWORD esp2; // 保存 2 环栈指针
    DWORD ss2;  // 保存 2 环栈段选择子
    // 下面这些都是用来做切换寄存器值用的，切换寄存器的时候由CPU自动填写。
    DWORD cr3; 
    DWORD eip;  
    DWORD eflags;
    DWORD eax;
    DWORD ecx;
    DWORD edx;
    DWORD ebx;
    DWORD esp;
    DWORD ebp;
    DWORD esi;
    DWORD edi;
    DWORD es;
    DWORD cs;
    DWORD ss;
    DWORD ds;
    DWORD fs;
    DWORD gs;
    DWORD ldt;
    // 这个暂时忽略
    DWORD io_map;
} TSS;

```

Intel的设计思想：在操作系统运行的时候，进行任务的切换。

Intel提到的任务对应的是操作系统的线程。

它在CPU层面叫任务，

操作系统层面叫线程。

当程序执行的时候，如果想做新的事情，或者新的任务，

那么上下文环境需要发生变化，不能使用原来的寄存器。

原来的寄存器存储的是上一个程序要用到的值。

如果要做新的事情，那肯定要新的寄存器，

那么新的寄存器从哪来呢？TSS。

当想要恢复原来的事情，只需要把原来的寄存器的值存到TSS中，

通过TSS再写入寄存器中就恢复原来的样子了。

所谓的任务切换，其实就是线程切换。


不要把TSS与 "任务切换" 联系到一起。

TSS的意义就在于可以同时替换掉 "一堆" 寄存器，仅此而已。



<p id="Attribute.DPL" style="color:#00FA9A;font-size:32px">
    TR寄存器
</p>

TR寄存器的值是当操作系统启动时，从**TSS段描述符**中加载出来的，TSS段描述符在GDT表中

TR.Base = TSS起始地址

TR.Limit = TSS大小



<p id="Attribute.DPL" style="color:#00FA9A;font-size:32px">
    TSS段描述符
</p>

![img](img/tss.png)



Type = 二进制1001：说明该TSS段描述符**未**被加载到TR段寄存器中

Type = 二进制1011：说明该TSS段描述符**已**被加载到TR段寄存器中

<div style="color:#00CED1;font-size:16px">
   	注意：<br>
   	高4字节的第23位，也就是G位。<br>
   	G位=0：代表limit界限单位是字节<br>
   	G位=1：代表limit界限单位是4KB。<br>
	前文中的实验通常都是1，本文中为0。<br>
	为什么是0？因为LIMIT指向的TSS是以字节为单位的。<br>
</div>



<p id="Attribute.DPL" style="color:#00FA9A;font-size:32px">
    TR寄存器读写
</p>

<p style="color:#FFA500;font-size:24px">
    写TR寄存器
</p>

指令：`LTR`

在R0可以通过LTR指令修改TR段寄存器。

说明：

1.  用LTR指令去装载的话 仅仅是改变TR寄存器的值(96位)
2.  并没有真正改变TSS
3.  LTR指令只能在系统层使用
4.  加载后TSS段描述符的状态位会发生改变

在R3可以通过 CALL FAR 或者 JMP FAR 指令修改。



用JMP去访问一个代码段的时候，改变的是CS和EIP：

JMP 0x48:0x123456，如果0x48是代码段，执行后：CS->0x48、EIP->0x123456。

用JMP去访问一个任务段的时候：

如果0x48是TSS段描述符，先修改TR段寄存器，再用TR.BASE指向的TSS中的值修改当前的寄存器。



<p style="color:#FFA500;font-size:24px">
    读TR寄存器
</p>

指令：`STR`

说明：如果用STR去读的话，只读了TR的16位，也就是段选择子



相关实验没做,没有环境



## 任务门



![image-20230116235203649](img/image-20230116235203649.png)

保留部分,随意写





INT N（N为IDT表索引号）

系统通过用户指定的索引查找IDT表，找到对应的门描述符

门描述符若为任务门描述符，则根据任务门描述符中TSS段选择子查找GDT表，找到TSS段描述符

将TSS段描述符中的内容加载到TR段寄存器

TR段寄存器通过Base和Limit找到TSS

使用TSS中的值修改寄存器

IRETD返回

相关实验没做,没环境





# 页的机制



## 引入

4GB内存空间

大家可能都听说过，每个程序在运行时，操作系统都会为其分配一段4GB的内存空间。

但是我们的内存容量很可能最多只够为一个进程分配4GB的内存空间，如何做到为每个进程都分配呢？

实际上，进程被分配到的`4GB内存空间`只是虚拟的的内存空间，

并不是指真正意义上的物理内存，虚拟内存与物理内存之间有一层转换关系

ps: 那`4GB内存空间`是假的

![img](img/4gb.png)



## 地址



<p id="Attribute.DPL" style="color:#00FA9A;font-size:32px">
    有效地址-线性地址
</p>

物理地址

以如下为例

```
MOV eax,dword ptr ds:[0x12345678]
```

其中，

0x12345678 是**有效地址**

ds.Base + 0x12345678 是**线性地址**

注意：当段[寄存器](https://so.csdn.net/so/search?q=寄存器&spm=1001.2101.3001.7020)的Base为0时，**有效地址**=**线性地址**，

大多数时候都是如此；但也有特殊情况，比如**fs段寄存器**的Base不为0

<p id="Attribute.DPL" style="color:#00FA9A;font-size:32px">
    物理地址
</p>

描述：

我们平时所用到的**系统DLL**（动态链接库）存在于物理地址中，

当程序想要调用某个DLL时，DLL便会映射一份线性地址给程序，

这样程序就能够通过线性地址找到DLL的物理地址



关于实验,我没去做,就说一下自己的理解吧

首先打开一个notpad.exe,往里面写入内容

然后用CE附加这个进程,然后用Unicode的方式扫描扫描字符串,寻找该内容

最后就可以获取一个线性地址

然后我们要做的就是把线性地址转化到物理地址

这里我们以`10-10-12`分页的方式为例

<div  style="color:#FFB5C5;font-size:16px">
    tips:<br>
    10-10-12的意思,就是把一个32位的数据分为10bit,10bit,12bit<br>
	然后10个bit位大小最大是1023,<br>
    也即是1024个数据<br>
</div>


如果通过CE获取的线性地址是0x06765140

然后我们划分数据,把3个数据提取出来,因为最后的12bit刚好3个16进制位,就不用划分了

```
0    6    7    6    5    140
=
0000 0110 0111 0110 0101 140
=
0000011001		// 0x19
1101100101		// 0x365
140				// 12个比特位刚好三个字节
```

所以我们提取出来就是0x19,0x365,0x140,

这3个数据是什么? 其实也就是一些表的索引值



```
!process 0 0 寻找进程,然后获取DirBase 是一个进程的物理地址
```

加入我们获取的DirBase是`0bd1000`

然后我们

tips:`!dd`是查看物理地址

```
!dd 0bd1000 + 0x19*4 //成员是DWORd Arr1[xx]
```

然后可以获取一个4字节数据,把后3位16进制置为0(后面讲诉)

```
!dd 08F17000 + 0x365*4	//成员是DWORd Arr2[xx]
```

然后可以获取一个4字节数据,把后3位16进制置为0(后面讲诉)

```
!dd 1D075000 + 0x140  //成员是BYTE Arr3[xx]
```



## PDE&PTE





![img](img/pdepte.png)



### 简单介绍

CR3：唯一一个存储物理地址的寄存器。

在Windows中，页大小是4KB。在后期会接触到另一种页，有4MB大小，称为大页。

CR3里面存储的地址，指向的PDT，表中每个成员称为PDE,PTE指向的才是真正的`物理页`。

无论是PDE或者PTE，都是4字节。它的十六进制形式的后三位存储的是属性


然后说一下为什么0地址不能读写

因为0地址一般不会给他分配物理页

那么,如果我们手动给他分配物理页的话,是完全可以实现0地址的读写

关于0地址读写问题,我希望后面你自己写个小实验




寻找我们已经分配的物理页









```c
#include "stdafx.h"
 
int main(int argc, char* argv[])
{
    int x = 1;
 
    printf("x的地址:%x\n", &x);
 
    getchar();
 
    //向0地址写入数据
    *(int*)0 = 123;
 
    //读取0地址上的数据
    printf("0地址数据:%x\n", *(int*)0);
 
    return 0;
}
```





1.  PTE可以指向物理页，也可以没有指向物理页。
2.  多个PTE可以指向一同一个物理页。
3.  一个PTE只能指向一个物理页



### 属性



## 小实验



打印



```c
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<windows.h>

int main()
{
	long long arrGDT[] = 
	{
		0x000000000000000, 0x0cf9b000000ffff, 0x0cf93000000ffff, 0x0cffb000000ffff,
		0x0cff3000000ffff ,0x80008b04200020ab, 0xffc093dff0000001, 0x040f30000000fff
	};
	
	//long long arrGDT[] = 
	//{
	//	0x00000000 00000000, 0x00cf9b00 0000ffff, 0x00cf9300  0000ffff, 0x00cffb00 0000ffff,
	//	0x00cff300 0000ffff ,0x80008b04 200020ab, 0xffc093df  f0000001, 0x0040f300 00000fff
	//};
	
	char* Seginfo[] = { "  系统段","非系统段" };
	char* priRing[] = { "R0","R1","R2","R3" };
	int SegLimit=0;
	int SegBase=0;
	int len = 0;
	int tmp = 0;
	len = sizeof(arrGDT)/sizeof(arrGDT[0]);
	int i = 0;
	for (i = 0; i < len; i++)
	{
		SegBase = (arrGDT[i] & 0x000000FFFFFF0000) >> 16 | (arrGDT[i] & 0xFF00000000000000)>>32;
		SegLimit = (arrGDT[i] & 0x00F0000000000000) >> (52+3) == 1 ? 0xFFFFFFFF : 0x000FFFFF;
		tmp = (arrGDT[i] & 0x0000F00000000000) >> (11*4);
		printf("[%d]段范围:%08X[%08X] ,段类型:%s 段权限:%s \n", i,SegBase, SegLimit,Seginfo[tmp >> 3], priRing[(tmp & 0b0110) >> 1]);
	}

	
	return 0;
}
/*
GS 去往:GDT 索引:0 然后请求:R0 段范围:00000000[000FFFFF] ,段类型:  系统段 段权限:R0
FS 去往:GDT 索引:7 然后请求:R3 段范围:00000000[000FFFFF] ,段类型:非系统段 段权限:R3
ES 去往:GDT 索引:4 然后请求:R3 段范围:00000000[FFFFFFFF] ,段类型:非系统段 段权限:R3
DS 去往:GDT 索引:4 然后请求:R3 段范围:00000000[FFFFFFFF] ,段类型:非系统段 段权限:R3
CS 去往:GDT 索引:3 然后请求:R3 段范围:00000000[FFFFFFFF] ,段类型:非系统段 段权限:R3
SS 去往:GDT 索引:4 然后请求:R3 段范围:00000000[FFFFFFFF] ,段类型:非系统段 段权限:R3

8003f000 0000000000000000 00cf9b000000ffff 00cf93000000ffff 00cffb000000ffff
8003f020 00cff3000000ffff 80008b04200020ab ffc093dff0000001 0040f30000000fff

段范围:00000000[000FFFFF] ,段类型:  系统段 段权限:R0
段范围:00000000[000FFFFF] ,段类型:非系统段 段权限:R0
段范围:00000000[000FFFFF] ,段类型:非系统段 段权限:R0
段范围:00000000[000FFFFF] ,段类型:非系统段 段权限:R3
段范围:00000000[000FFFFF] ,段类型:非系统段 段权限:R3
段范围:80042000[000FFFFF] ,段类型:非系统段 段权限:R0
段范围:FFDFF000[000FFFFF] ,段类型:非系统段 段权限:R0
段范围:00000000[000FFFFF] ,段类型:非系统段 段权限:R3
*/
```

