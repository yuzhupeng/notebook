

# 代码跨段(入门)

为什么说是初入?

因为这里面涉及很多东西,,所以就简单的介绍一下,,,细节会在之后单独提出来的



分为很多情况的

比如`JMP FAR`

比如 `CALL FWORD PTR`



期间涉及线程环境的切换

可以实现代码跨段的指令,期间可能会修改CS:IP,甚至SS:SP

```
jmp far
call far
int
retf
iret(16位)
iretd(32位)
//这些指令有什么区别,那是后面会讲到的
```

然后还能够修改CS,IP的 ->sysentry,sysexit,



段,我感觉应该是一种环境,,比如我代码跨段

前往的虚拟地址甚至可以是一样的,,,但是线程环境不再是一样的

就像是`CALL FWORD PTR`不提权,去往附近的地方



段间跳转分为两种情况：

1.  要跳转的段是一致代码段 ,存在跨级访问
2.  要跳转的段是非一致代码段,各自调用各自的

但是我们通常使用的是`非一致代码段`的跨段,因为那样更加方便,不容易出错吧



> 最后引出一个小结论,是通过前人总结的

jmp,call是可以用来提权的

但是 jmp,call, 不调用`门`,或者不调用`TSS`,只能在同级之间跳转

retf,iretd呢,只能在同级之间跳转,或者只能降级跳转



<div  style="color:#FFB5C5;font-size:16px">
    注意：直接对代码段进行JMP 或者 CALL的操作，<br>
	无论目标是一致代码段还是非一致代码段，CPL当前权限都不会发生改变.<br>
    如果要提升CPL的权限，只能通过调用门<br>
</div>




## JMP FAR 段间跳转

jmp的跳转不涉及栈的变化...? 可能吧



### 不提权的JMP



```
JMP x:y
机器码是
EA 34124000(y) 2000(x)
```

该指令要提供6字节的参数(2+4)==(段选择子+偏移)



对于这种,是修改CS:IP的

但不会修改SS:SP

`JMP x:y`的y就是去往目标地方的偏移

比如x=0x004B,Y=0x0040101A



关于一些权限检查之类的,,我想通过后面的一些驱动演示,,拿到0环的权限才方便做一些实验

比如严重 CPL>=DPL才可以跳转成功

但是目前的CPL,我们只有R3的,,,R0的暂时拿不到









#### 实验1 



```
gdtr=8003f000
0: kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff //[0],[1]
8003f010  00cf9300`0000ffff 00cffb00`0000ffff //[2],[3]
8003f020  00cff300`0000ffff 80008b04`200020ab //[4],[5]
8003f030  ffc093df`f0000001 0040f300`00000fff //[6],[7]
8003f040  0000f200`0400ffff 00000000`00000000 //[8],[9]
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

首先CS=0x001B

```
CS 去往:GDT 索引:3 然后请求:R3
```

索引的值是[3]=00cffb00`0000ffff

于是我们为了突出效果,在[9]:8003f048的地方插入值00cffb00`0000ffff

```
0: kd> eq 8003f048 00cffb00`0000ffff
0: kd> dq 8003f000
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cffb00`0000ffff //发生改变
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
0: kd> g
```



打算跳往的选择子是0x004B

```
0x004B: 去往:GDT 索引:9 然后请求:R3
```

然后后续我么直接跳到main函数罢了

```
JMP FAR 0x004B:0x00401010 //0x00401010函数地址
```

跳转前

![image-20230126202425362](./img/image-20230126202425362.png)

跳转后

![image-20230126202717833](./img/image-20230126202717833.png)



如果我们跳往的不是CS段,而是DPL为ring0的段

```
0: kd> eq 8003f048 00cf9b00`0000ffff
0: kd> g
```

 00cf9b00`0000ffff 段范围:00000000[FFFFFFFF] ,段类型:非系统段 段权限:R0

于是我们尝试从非非一致代码段,从R3 JMP FAR 到R0

直接触发异常

![image-20230126210321859](./img/image-20230126210321859.png)



#### 实验2 



是一个一致代码段的实验

通过call far实现了R3调用R0

同时他还需要修改页的一些东西

这个可以参考

```c++
\火哥内核1-\保护模式\09.段跳转流程;
\火哥内核1-\保护模式\10.段跳转实验-一致代码段分析
```

但是没看懂的



#### 实验3



##### 情景1



很简单的一个实验

我们把CS的段选择子挪到一个地方去

CS:0x1B,CPL是3环

0x48是cv了CS的段选择子,但是0x48的RPL=0环

```c++
kd> dq gdtr
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cffb00`0000ffff
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

然后尝试去跳转, 可能猜测会失败

因为CPL=目标DPL=3环,目标段选择子是0环的RPL



发现跳转成功

![image-20230909193847995](./img/image-20230909193847995.png)

但是CS!=0x48,而是等于0x4B...为什么?

![image-20230909194308657](./img/image-20230909194308657.png)



当访问的RPL=0, 同时CPL=目标DPL,

如果JMP成功,会强行把最后的CPL该为目标DPL权限

所以

```c++
In [8]: bin(0x4b)
Out[8]: '0b1001011'

In [9]: bin(0x48)
Out[9]: '0b1001000'
```



如果CPL=0,目标RPL=3,目标DPL=0

那么最后的RPL会被强行转化为0

另外.RPL是请求权限,不是一定要给你

真正比较的是CPL和DPL



##### 情景2

重复之前的操作

如果CPL=3, 目标DPL=0,目标RPL=0

去jmp就会出现异常

![image-20230909200811315](./img/image-20230909200811315.png)

ps: 之前的跳转CPL=3, 目标DPL=3,目标RPL=0是正常的



##### 情景3(不明白)

重复之前的操作

如果CPL=3, 目标DPL=0,目标RPL=0

但是我们用的是一致代码段

一致代码段就是可以 低级别越权访问

```c++
|         (00cf9f00`0000ffff)
|         (00000000)[0,000FFFFF)        |
|---------------------------------------|
| TYPE | S | DPL | P | AVL | - | DB | G |
| 1111 | 1 | 00  | 1 | 0   | 0 | 1  | 1 |
|---------------------------------------|
```



然后查看

```c++
kd> eq 8003f048 00cf9f00`0000ffff
kd> dq gdtr
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00cf9f00`0000ffff
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff

```

再跳一下看看

发现可以跳转成功

![image-20230909202138395](./img/image-20230909202138395.png)



但是呢

CPL=3,DPL=0,RPL=0

但是最后,依然CPL=3

没有实现一个CPL=0



如果我们一开始是

CPL=3,RPL=3,DPL=0呢

就会出现异常...呵呵

之前好像说,,权限至少得是DPL之上,,所以这是异常的原因还是什么???

不太明白









##### 情节4

这个就是用的call

CPL=3, 目标DPL=0,目标RPL=0

看是否可以成功的call

```c++
0: kd> eq 8003f048 00cf9b00`0000ffff
|         (00cf9b00`0000ffff)
|         (00000000)[0,000FFFFF)        |
|---------------------------------------|
| TYPE | S | DPL | P | AVL | - | DB | G |
| 1101 | 1 | 00  | 1 | 0   | 0 | 1  | 1 |
|---------------------------------------|
```



CPL=3,DPL=0,RPL=0

发现跳转失败

![image-20230909203217264](./img/image-20230909203217264.png)

说明什么,,在CPL=3,DPL=0,RPL=0的情况下,,,使用call,也失败

call在不调用门,TSS的情况下,,仍然不能提权,,只能在同一级别之间跳转



```c++
#include<stdio.h>
void test(){
	printf("hi you get me\n");
	return ;
}
int main()
{
	char buf[]={0,0,0,0,0x48,0};
	*(int*)buf=(int)test;
	__asm{
		call fword ptr ds:[buf];
	}
	return 0;
}
```



然后我们尝试在同一级别之间call

```c++
0: kd> eq 8003f048 00cffb00`0000ffff;
|         (00cffb00`0000ffff)
|         (00000000)[0,000FFFFF)        |
|---------------------------------------|
| TYPE | S | DPL | P | AVL | - | DB | G |
| 1101 | 1 | 11  | 1 | 0   | 0 | 1  | 1 |
|---------------------------------------|
```



CPL=3,DPL=3,RPL=0;

可以看见就成功跳转过去了

但是还是会遇到一些问题

比如在test下断点,就g了

![image-20230909205121014](./img/image-20230909205121014.png)



在没有call进去时

![image-20230909211127072](./img/image-20230909211127072.png)

call进去后

![image-20230909211235311](./img/image-20230909211235311.png)



尝试使用retf正常返回



```c++
0: kd> dq gdtr
8003f000  00000000`00000000 00cf9b00`0000ffff
8003f010  00cf9300`0000ffff 00cffb00`0000ffff
8003f020  00cff300`0000ffff 80008b04`200020ab
8003f030  ffc093df`f0000001 0040f300`00000fff
8003f040  0000f200`0400ffff 00000000`00000000
8003f050  80008955`27000068 80008955`27680068
8003f060  00009302`2f40ffff 0000920b`80003fff
8003f070  ff0092ff`700003ff 80009a40`0000ffff
0: kd> eq 8003f048  00cffb00`0000ffff

```



```c++
#include<stdio.h>
int gvar=10;
void _declspec(naked) test()
{
	__asm{
		push eax;
		push ecx;
		lea eax,gvar;
		xor ecx,ecx;
		mov [eax],ecx;
		pop ecx;
		pop eax;
		retf;
	}
}
int main()
{
	char buf[]={0,0,0,0,0x48,0};
	*(int*)buf=(int)test;
	printf("hi i am hello world\n");
	printf("%08X\n",gvar);
	__asm{
		call fword ptr ds:[buf];
	}
	printf("%08X\n",gvar);
	return 0;
}
```



执行如下

![image-20230909214119877](./img/image-20230909214119877.png)



### 提权的JMP

略,,后面说吧





## CALL FAR 段间调用(调用门引入)

不同于之前的call

现在的call far不仅仅是push ip了

既然是call far,那么函数的返回就不再是ret

而不是retf

但是retf又分为2种情况来返回

一种是不需要提权的reft,会把栈中2个东西pop出来

另外一种是经过提权的retf,会把栈中4个东西pop出来,此刻的retf就是用来降权啦





![image-20230910085358203](./img/image-20230910085358203.png)

左边是不提权的call far, 把CS:IP入栈

右边是提权的call far,把SS:SP,CS:IP入栈了



### 不提权

不提权的话, CALL FAR XX:YYYY

其中CPL=目标的DPL

真正去往的地址是YYYY



期间会push这些东西,不仅仅有这些哈

```
EIP
CS
```



### 提权

指令格式：CALL XX:EIP(EIP是废弃的)

ps: 在调用门那里我们会详细的介绍

跨段调用时，一旦有权限切换，伴随着以一个新的堆栈出现。

CS的权限一旦改变，SS的权限也要随着改变，即CS与SS的等级必须一样。

新的堆栈里面,初步的值会是下面的样子

```
栈顶:	   EIP //返回的地址
		CS //以前的cs
		ESP //以前的栈顶
		SS //以前的ss
```

新的堆栈来源于参见TSS段

后面会讲到关于CALL的提权


