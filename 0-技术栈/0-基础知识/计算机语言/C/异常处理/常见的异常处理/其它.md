# 其它

想我告诉过你，当一个线程出现错误时，操作系统给你一个机会被告知这个错误。

说得更明白一些就是，**当一个线程出现错误时，操作系统调用用户定义的一个回调函数**。

这个回调函数可以做它想做的一切。例如它可以修复错误，或者它也可以播放一段音乐。

无论回调函数做什么，它最后都要返回一个值来告诉系统下一步做什么。（这不是十分准确，但就此刻来说非常接近。）

- - dvlinker from csdn

敲黑板:

SEH是局部的(栈中),是基于线程的

VEH,UEF,VCH是全局的(堆中),基于进程的

重要的事情说3编:
VEH/UEF/VCH的处理函数都是stdcall
所以不要拿着一个 __cdecl  去注册一个应该stdcall的函数
否则会导致堆栈不平衡,导致函数参数读取错误,或者函数返回有问题等等

# API触发异常

```c
void RaiseException(
[in] DWORD           dwExceptionCode,
[in] DWORD           dwExceptionFlags,
[in] DWORD           nNumberOfArguments,
[in] const ULONG_PTR *lpArguments
);
```

# **jmp_buf**

jmp_buf 是一个数据类型

setjmp(jmp_buf_var) 就是初始化一个变量jmp_buf_var,第一次初始化会返回0

jmp_buf_var 里面保存了在当前ip的运行环境

longjmp(jmp_buf_var,1);就是根据jmp_buf_var的环境,跳转到上一次保存的环境,那个1是任意的一个返回值

因为setjmp很好的保存了各个寄存器的值,所以就可以很好的跳转回去正常运行(除非变量的依赖性不是很强)

```c
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

//异常的特征码,无关紧要
typedef enum _ErrorCode_
{
    ERR_OK = 100,
    ERR_DIV_BY_ZERO = -1
    } ErrorCode;

jmp_buf gExcptBuf;
typedef int (*pf)(int, int);
int my_div(int a, int b)
{
    if (b==0)
    {
        printf("try excepton. error = %d \n", ERR_DIV_BY_ZERO);
        longjmp(gExcptBuf,1);//ERR_DIV_BY_ZERO 是携带的返回值
    }
    return a / b;
}
int my_try(pf func, int a, int b)
{
    int flag = setjmp(gExcptBuf);   //保存才开始的环境
    int sum=0;
    if (flag==0)
    {
        sum=func(a, b); //正常的调用
        return sum;
    }
    return 0;
}
int main()
{
    int result = my_try(my_div, 8, 0);
    //int result = my_try(my_div, 8, 2);
    printf("%d\n",result);
    puts("GoodBye");
    return 0;
}
```

# 异常表

## **总览**

```c
/*lint -save -e767 */  
#define STATUS_WAIT_0                           ((DWORD   )0x00000000L) 
#define STATUS_ABANDONED_WAIT_0          ((DWORD   )0x00000080L)    
#define STATUS_USER_APC                  ((DWORD   )0x000000C0L)    
#define STATUS_TIMEOUT                   ((DWORD   )0x00000102L)    
#define STATUS_PENDING                   ((DWORD   )0x00000103L)    
#define DBG_EXCEPTION_HANDLED            ((DWORD   )0x00010001L)    
#define DBG_CONTINUE                     ((DWORD   )0x00010002L)    
#define STATUS_SEGMENT_NOTIFICATION      ((DWORD   )0x40000005L)    
#define STATUS_FATAL_APP_EXIT            ((DWORD   )0x40000015L)    
#define DBG_TERMINATE_THREAD             ((DWORD   )0x40010003L)    
#define DBG_TERMINATE_PROCESS            ((DWORD   )0x40010004L)    
#define DBG_CONTROL_C                    ((DWORD   )0x40010005L)    
#define DBG_PRINTEXCEPTION_C             ((DWORD   )0x40010006L)    
#define DBG_RIPEXCEPTION                 ((DWORD   )0x40010007L)    
#define DBG_CONTROL_BREAK                ((DWORD   )0x40010008L)    
#define DBG_COMMAND_EXCEPTION            ((DWORD   )0x40010009L)    
#define STATUS_GUARD_PAGE_VIOLATION      ((DWORD   )0x80000001L)    
#define STATUS_DATATYPE_MISALIGNMENT     ((DWORD   )0x80000002L)    
#define STATUS_BREAKPOINT                ((DWORD   )0x80000003L)    
#define STATUS_SINGLE_STEP               ((DWORD   )0x80000004L)    
#define STATUS_LONGJUMP                  ((DWORD   )0x80000026L)    
#define STATUS_UNWIND_CONSOLIDATE        ((DWORD   )0x80000029L)    
#define DBG_EXCEPTION_NOT_HANDLED        ((DWORD   )0x80010001L)    
#define STATUS_ACCESS_VIOLATION          ((DWORD   )0xC0000005L)    
#define STATUS_IN_PAGE_ERROR             ((DWORD   )0xC0000006L)    
#define STATUS_INVALID_HANDLE            ((DWORD   )0xC0000008L)    
#define STATUS_INVALID_PARAMETER         ((DWORD   )0xC000000DL)    
#define STATUS_NO_MEMORY                 ((DWORD   )0xC0000017L)    
#define STATUS_ILLEGAL_INSTRUCTION       ((DWORD   )0xC000001DL)    
#define STATUS_NONCONTINUABLE_EXCEPTION  ((DWORD   )0xC0000025L)    
  #define STATUS_INVALID_DISPOSITION       ((DWORD   )0xC0000026L)    
  #define STATUS_ARRAY_BOUNDS_EXCEEDED     ((DWORD   )0xC000008CL)    
  #define STATUS_FLOAT_DENORMAL_OPERAND    ((DWORD   )0xC000008DL)    
  #define STATUS_FLOAT_DIVIDE_BY_ZERO      ((DWORD   )0xC000008EL)    
  #define STATUS_FLOAT_INEXACT_RESULT      ((DWORD   )0xC000008FL)    
  #define STATUS_FLOAT_INVALID_OPERATION   ((DWORD   )0xC0000090L)    
  #define STATUS_FLOAT_OVERFLOW            ((DWORD   )0xC0000091L)    
  #define STATUS_FLOAT_STACK_CHECK         ((DWORD   )0xC0000092L)    
  #define STATUS_FLOAT_UNDERFLOW           ((DWORD   )0xC0000093L)    
  #define STATUS_INTEGER_DIVIDE_BY_ZERO    ((DWORD   )0xC0000094L)    
  #define STATUS_INTEGER_OVERFLOW          ((DWORD   )0xC0000095L)    
  #define STATUS_PRIVILEGED_INSTRUCTION    ((DWORD   )0xC0000096L)    
  #define STATUS_STACK_OVERFLOW            ((DWORD   )0xC00000FDL)    
  #define STATUS_DLL_NOT_FOUND             ((DWORD   )0xC0000135L)    
  #define STATUS_ORDINAL_NOT_FOUND         ((DWORD   )0xC0000138L)    
  #define STATUS_ENTRYPOINT_NOT_FOUND      ((DWORD   )0xC0000139L)    
  #define STATUS_CONTROL_C_EXIT            ((DWORD   )0xC000013AL)    
  #define STATUS_DLL_INIT_FAILED           ((DWORD   )0xC0000142L)    
  #define STATUS_FLOAT_MULTIPLE_FAULTS     ((DWORD   )0xC00002B4L)    
  #define STATUS_FLOAT_MULTIPLE_TRAPS      ((DWORD   )0xC00002B5L)    
  #define STATUS_REG_NAT_CONSUMPTION       ((DWORD   )0xC00002C9L)    
  #define STATUS_HEAP_CORRUPTION           ((DWORD   )0xC0000374L)    
  #define STATUS_STACK_BUFFER_OVERRUN      ((DWORD   )0xC0000409L)    
  #define STATUS_INVALID_CRUNTIME_PARAMETER ((DWORD   )0xC0000417L)    
  #define STATUS_ASSERTION_FAILURE         ((DWORD   )0xC0000420L)    
  #if defined(STATUS_SUCCESS) || (_WIN32_WINNT > 0x0500) || (_WIN32_FUSION >= 0x0100) 
  #define STATUS_SXS_EARLY_DEACTIVATION    ((DWORD   )0xC015000FL)    
  #define STATUS_SXS_INVALID_DEACTIVATION  ((DWORD   )0xC0150010L)    
  #endif 
  /*lint -restore */
```

## **常见的异常**

```c
EXCEPTION_DATATYPE_MISALIGNMENT        (0x80000002)   程序读取一个未经对齐的数据时引发的异常。
EXCEPTION_BREAKPOINT                   (0x80000003)   断点异常
EXCEPTION_SINGLE_STEP                  (0x80000004)   标志寄存器的TF位为1时，每执行一条指令就会引发该异常
EXCEPTION_IN_PAGE_ERROR                (0x80000006)
EXCEPTION_ILLEGAL_INSTRUCTION          (0x8000001D)   无法识别的指令
EXCEPTION_NONCONTINUABLE_EXCEPTION     (0x80000025)
EXCEPTION_INVALID_DISPOSITION          (0x80000026)
EXCEPTION_ARRAY_BOUNDS_EXCEEDED        (0x8000008C)
EXCEPTION_FLT_DENORMAL_OPERAND         (0x8000008D)
EXCEPTION_INT_DIVIDE_BY_ZERO           (0x80000094)   除法运算分母为0

EXCEPTION_ACCESS_VIOLATION     			0xC0000005     
//程序企图读写一个不可访问的地址时引发的异常。例如企图读取0地址处的内存。

EXCEPTION_ARRAY_BOUNDS_EXCEEDED    		0xC000008C     
//数组访问越界时引发的异常

EXCEPTION_FLT_DENORMAL_OPERAND     		0xC000008D     
//如果浮点数操作的操作数是非正常的，则引发该异常。所谓非正常，即它的值太小以至于不能用标准格式表示出来。

EXCEPTION_FLT_DIVIDE_BY_ZERO            0xC000008E     浮点数除法的除数是0时引发该异常。  
EXCEPTION_FLT_INEXACT_RESULT            0xC000008F     浮点数操作的结果不能精确表示成小数时引发该异常。  
EXCEPTION_FLT_INVALID_OPERATION         0xC0000090     该异常表示不包括在这个表内的其它浮点数异常。  
EXCEPTION_FLT_OVERFLOW                  0xC0000091     浮点数的指数超过所能表示的最大值时引发该异常。  
EXCEPTION_FLT_STACK_CHECK               0xC0000092     进行浮点数运算时栈发生溢出或下溢时引发该异常。   
EXCEPTION_FLT_UNDERFLOW                 0xC0000093     浮点数的指数小于所能表示的最小值时引发该异常。   
EXCEPTION_ILLEGAL_INSTRUCTION           0xC000001D     程序企图执行一个无效的指令时引发该异常。   
EXCEPTION_IN_PAGE_ERROR                 0xC0000006     程序要访问的内存页不在物理内存中时引发的异常。
EXCEPTION_INT_DIVIDE_BY_ZERO            0xC0000094     整数除法的除数是0时引发该异常。
EXCEPTION_INT_OVERFLOW                  0xC0000095     整数操作的结果溢出时引发该异常。
EXCEPTION_INVALID_DISPOSITION           0xC0000026     异常处理器返回一个无效的处理的时引发该异常。
EXCEPTION_NONCONTINUABLE_EXCEPTION      0xC0000025     发生一个不可继续执行的异常时，如果程序继续执行，则会引发该异常。
EXCEPTION_PRIV_INSTRUCTION              0xC0000096     程序企图执行一条当前CPU模式不允许的指令时引发该异常。
EXCEPTION_STACK_OVERFLOW                0xC00000FD     栈溢出时引发该异常。
```