# 遇到的一些问题

# count++ % 3 == 0 吐了

汇编翻译吐了

```
/* count.c -- using standard I/O */
 #include <stdio.h>
 int main(int argc, char *argv[])
 {
     while ((ch = getc(in)) != EOF)
     {
         if (count++ % 3 == 0)
             ...
     }
     return 0;
 }
```

```
 //int版本
 mov     ecx, [esp+1Ch]
 lea     eax, [ecx+1]
 mov     [esp+28], eax
 mov     edx, 55555556h
 mov     eax, ecx
 imul    edx
 mov     eax, ecx
 sar     eax, 31
 sub     edx, eax
 mov     eax, edx
 mov     edx, eax
 add     edx, edx
 add     edx, eax
 mov     eax, ecx
 sub     eax, edx
 test    eax, eax
 jnz     short loc_4015A9
 //byte版本
 movzx   ecx, byte ptr [esp+31]
 mov     eax, ecx
 add     eax, 1
 mov     [esp+31], al
 movsx   ax, cl
 imul    eax, 86
 shr     ax, 8
 mov     edx, eax
 mov     eax, ecx
 sar     al, 7
 sub     edx, eax
 mov     eax, edx
 mov     edx, eax
 add     edx, edx
 add     edx, eax
 mov     eax, ecx
 sub     eax, edx
 test    al, al
 jnz     short loc_4015AD
```

它的意思是

```
 #include <stdio.h>
//byte版本
 int main(int argc, char *argv[])
 {
     int result=0;//eax
     int count=6;//ecx, byte ptr [esp+31]
     result=count-3*((count*86)>>8-(count>>7));
     return 0;
 }
//int版本
/*
int result=0;
int count=10;
result-=count-3*(count*0x55555556>>32-count>>31);
*/
```

我还是看不懂

# ds:__iob_func

`__iob_func()`返回一个指向`FILE`描述符数组的指针，

该数组包含`stdin`、`stdout`和通过 C 运行时库打开的`stderr`任何对象。

# RTC_CheckEsp

参数 ZF寄存器

它主要分布在一些函数调用之间,

也就是函数前mov esi,ebp

函数结束后就cmp esi,ebp

验证`esp`, stack, register 正确性的调用。调用它以确保`esp`在函数调用中保存 的值。

```
 0044EE35  mov         esi,esp
     .....一些操作
     ......
 0044EE4D  cmp         esi,esp
 0044EE4F  call        @ILT+6745(__RTC_CheckEsp) (42BA5Eh)
```

在那一顿操作过后,他就检测栈是否还原

就是比较esi与esp

# 关于函数__RTC_CheckEsp

```
 _RTC_CheckEsp:
 00475A60  jne         esperror (475A63h)
 00475A62  ret//如果相等就返回
//不相等就死了
 esperror:
 00475A63  push        ebp
 00475A64  mov         ebp,esp
 00475A66  sub         esp,0
 00475A69  push        eax
 00475A6A  push        edx
 00475A6B  push        ebx
 00475A6C  push        esi
 00475A6D  push        edi
 00475A6E  mov         eax,dword ptr [ebp+4]
 00475A71  push        0
 00475A73  push        eax
 00475A74  call        _RTC_Failure (42C34Bh)
 00475A79  add         esp,8
 00475A7C  pop         edi
 00475A7D  pop         esi
 00475A7E  pop         ebx
 00475A7F  pop         edx
 00475A80  pop         eax
 00475A81  mov         esp,ebp
 00475A83  pop         ebp
 00475A84  ret
```

# @__security_check_cookie

基于Cookie的缓冲区溢出安全检查！

这个Cookie的变量位于函数体内的局部变量和EBP的存放地址之间，具体表示就是：[EBP-4]。

**security_init_cookie()这个函数对**security_cookie变量再次初始化

```
//获取cooike变量
//每个函数的ebp保持不变且不同,于是coike与ebp异或
//把cooike压入ebp-4
 mov eax,dword ptr [___security_cookie (4B7A74h)]
 xor eax,ebp
 mov dword ptr [ebp-4],eax
```

关于cooike在栈中的位置

就是最开始压入EBP后ESP的值，

ebp减4就刚好挨着一进函数时压入的EBP的地址减4。好了！Cookie变量已经在栈帧中了。

```
 .text:00991010 push    ebp//这里是ebp位置
 .text:00991011 mov     ebp, esp
 .text:00991013 sub     esp, 13Ch//esp的开辟
```

```
 00F5FBA0  66DDC4AD//cooike
 00F5FBA4  00F5FBF4  Stack[000022C4]:00F5FBF4//ebp
 00F5FBA8  0099170F  ___tmainCRTStartup+1BF
```

与EBP异或当然有好处。

1. 可以增加随机性，尽可能使不同函数的安全Cookie都不同。
2. 可以检查EBP是否被破坏，因为在函数结束检查Cookie时，还会将Cookie变量值再次与EBP异或，如果EBP的值没有变化，那么就能恢 复成原来的___security_cookie值。

一系列过程允许后又回到

```
//取出cokkie变量
//还原cookie变量
//检查是否和原来一样
 mov         ecx,dword ptr [ebp-4]
 xor         ecx,ebp
 call        @ILT+920(@__security_check_cookie@4) (43739Dh)
```

好像函数@__security_check_cookie@4采用了某个调用约定,所以的话ecx是第一个参数

```
 .text:00991220 ; void __fastcall __security_check_cookie(uintptr_t StackCookie)//某个调用约定
 .text:00991220 @__security_check_cookie@4 proc near    ; CODE XREF: _main_0+153↑p
 .text:00991220                                         ; failwithmessage(void *,int,int,char const *)+208↓p ...
 .text:00991220 cmp     ecx, ___security_cookie//把参数于原始的cooike做一个比较
 .text:00991226 jnz     short $failure$26820//不相等就死翘翘
 .text:00991228 rep retn
 .text:0099122A ; ---------------------------------------------------------------------------
 .text:0099122A
 .text:0099122A $failure$26820:                         ; CODE XREF: __security_check_cookie(x)+6↑j
 .text:0099122A jmp     ___report_gsfailure//到这里来了后就处理cooike不正常的处理
 .text:0099122A @__security_check_cookie@4 endp
```

# @_RTC_CheckStackVar

顾名思义，就是用来检查局部数据是否访问越界。

相对来说，

==这种检查只能起到一定的作用==，并不会所有越界访问都能检查到。

==既然是检查局部的==，那么在函数内定义的static类型数组或者函数外部的全局数组并不会采用此检查，

==既然是检查数组==，那么如果函数内没有局部数组时，此检查也不会存在。

> 背景
> 
> 
> 在VS的debug版本下，局部变量之间并不是连续存放在栈内存里的
> 
> 而是以4字节对齐的方式，前后都会有保护字节的。保护字节占4个字节，可能是值为0xcc，很明显这是汇编指令int 3中断的代码字节
> 

原始代码void  *_fastcall _RTC_CheckStackVars( void **Esp, *RTC_framedesc **Fd );

参数

ecx 	原来函数的ebp

edx	一个fd结构体指针

参数传递

```
 .text:0099114B mov     ecx, ebp//参数1                     ; Esp
 .text:0099114D push    eax
 .text:0099114E lea     edx, Fd//参数2
 .text:00991154 call    @_RTC_CheckStackVars@8
```

关于fd结构体类型

```
 typedef struct _RTC_framedesc
 
 {
     int varCount;//  要检查的数组的个数
     _RTC_vardesc *variables;//  要检查的数组的相关信息
 
 } _RTC_framedesc;
```

关于嵌套的结构体 _RTC_vardesc

```
 typedef struct _RTC_vardesc
 
 {
     int addr;//  数组的首地址相对于EBP的偏移量
     int size;//  数组的大小字节数
     char *name;//  数组的名字
 } _RTC_vardesc;
```

起反汇编代码

也不是很难.....

瞎看C代码--基于vs2008

```
 typedef struct _RTC_vardesc
 {
     int addr;
     int size;
     char* name;
 } _RTC_vardesc;
 
 typedef struct _RTC_framedesc
 {
     int varCount;
     _RTC_vardesc* variables;//结构体指针
 } _RTC_framedesc;
 
 void __fastcall _RTC_CheckStackVars( void* _Esp, _RTC_framedesc* _Fd )//ecx,edx
 {
     if ( _Fd->varCount == 0 )
         return;
//如果数组个数是0,就不检测
 
     int _RetAddr = 0;
     __asm
     {
         mov eax, ebp
         add eax, 4
         mov _RetAddr, eax// 保存返回地址
     }
 
     int i = 0;
     while ( i < _Fd->varCount )//i<数组的个数
     {
         char* pAddr = ( char* )_Esp + _Fd->variables[i].addr - 4;
         if ( *( int* )pAddr != 0xcccccccc )
             __asm int 3// 引发中断

         int ofs = _Fd->variables[i].addr + _Fd->variables[i].size;
         pAddr = ( char* )_Esp + ofs;
 
         if ( *( int* )pAddr != 0xcccccccc )
             __asm int 3// 引发中断
         ++i;
     }
 }
```

vs2010的IDA伪代码

```
 void __fastcall _RTC_CheckStackVars(void *Esp, _RTC_framedesc *Fd)
 {
   int v2;// edi
   _RTC_vardesc *variables;// eax
   int addr;// ecx
   int i;// [esp+Ch] [ebp-4h]
   void *retaddr;// [esp+14h] [ebp+4h]
 
   v2 = 0;
   for ( i = 0; i < Fd->varCount; ++i )
   {
     variables = Fd->variables;//包含数组信息的结构体
     addr = variables[v2].addr;//[index]小结构体的指针
//检测对应数组2边的保护字节????0xcc
     if ( *(_DWORD *)((char *)Esp + addr - 4) != 0xCCCCCCCC
       || *(_DWORD *)((char *)Esp + addr + variables[v2].size) != 0xCCCCCCCC )
     {
       _RTC_StackFailure(retaddr, variables[v2].name);
     }
     ++v2;
   }
 }
```

vs2008的汇编

```
 .text:00991260 ; void __fastcall _RTC_CheckStackVars(void *Esp, _RTC_framedesc *Fd)
 .text:00991260 @_RTC_CheckStackVars@8 proc near        ; CODE XREF: _main_0+144↑p
 .text:00991260
 .text:00991260 var_4= dword ptr -4
 .text:00991260
 .text:00991260 mov     edi, edi

 .text:00991262 push    ebp
 .text:00991263 mov     ebp, esp

 .text:00991265 push    ecx
 .text:00991266 push    ebx
 .text:00991267 push    esi
 .text:00991268 push    edi

 .text:00991269 xor     edi, edi
 .text:0099126B mov     esi, edx// 将_RTC_framedesc结构指针赋值给esi
 .text:0099126D mov     ebx, ecx// 将函数的栈帧赋值给ebx
 .text:0099126F mov     [ebp+var_4], edi// 这里的i应该是循环变量，后面根据数组的个数循环检测

 .text:00991272 cmp     [esi], edi//cmp fd,0   比较数值个数是否为0

 .text:00991274 jle     short loc_9912BE//没有数组,万事大吉,通过检测
 .text:00991276 jmp     short loc_991280//进一步检测
 .text:00991276 ; ---------------------------------------------------------------------------
 .text:00991278 align 10h
 .text:00991280
 .text:00991280 loc_991280:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+16↑j
 .text:00991280                                         ; _RTC_CheckStackVars(x,x)+5C↓j
 .text:00991280 mov     eax, [esi+4]//  +4之后就是_RTC_framedesc.variables指针
 .text:00991283 mov     ecx, [eax+edi]//  _RTC_vardesc->addr了，就是数组的首地址相对于TestVars的EBP的偏
 .text:00991286 cmp     dword ptr [ecx+ebx-4], 0CCCCCCCCh//  如果不等于0xcccccccc就报错_RTC_StackFailure
 .text:0099128E jnz     short loc_99129F
 .text:00991290 mov     edx, [eax+edi+4]
 .text:00991294 add     edx, ecx
 .text:00991296 cmp     dword ptr [edx+ebx], 0CCCCCCCCh
 .text:0099129D jz      short loc_9912B0
 .text:0099129F
 .text:0099129F loc_99129F:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+2E↑j
 .text:0099129F mov     ecx, [eax+edi+8]//即是_RTC_vardesc->name，用于报错提示
 .text:009912A3 mov     edx, [ebp+4]
 .text:009912A6 push    ecx                             ; char *// 传入越界的数组名
 .text:009912A7 push    edx                             ; void *
// 传入edx=EBP+4的地址，此地址正是_RTC_CheckStackVars的返回地址，用于定位
 .text:009912A8 call    ?_RTC_StackFailure@@YAXPAXPBD@Z ; _RTC_StackFailure(void *,char const *)
// 调用此函数后，弹出异常MessageBox，提示哪个数组越界
 .text:009912AD add     esp, 8
 .text:009912B0
 .text:009912B0 loc_9912B0:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+3D↑j
 .text:009912B0 mov     eax, [ebp+var_4]// 存在多个数组需要检查时有用
 .text:009912B3 inc     eax
 .text:009912B4 add     edi, 0Ch// 定位到下一个_RTC_vardesc结构
 .text:009912B7 mov     [ebp+var_4], eax
 .text:009912BA cmp     eax, [esi]
 .text:009912BC jl      short loc_991280
 .text:009912BE

 .text:009912BE loc_9912BE:                             ; CODE XREF: _RTC_CheckStackVars(x,x)+14↑j
 .text:009912BE pop     edi
 .text:009912BF pop     esi
 .text:009912C0 pop     ebx
 .text:009912C1 mov     esp, ebp
 .text:009912C3 pop     ebp
 .text:009912C4 retn
 .text:009912C4 @_RTC_CheckStackVars@8 endp
```

# 基于数组缓冲区溢出修改ip

```
 #include<stdio.h>

 void HelloWord()
 {
     printf("Hello World");
 }
 void Fun()
 {
     int arr[5] = {1,2,3,4,5};
     arr[6] = (int)HelloWord;
 }
 int main()
 {
     Fun();
 }
//运行环境 devc++ x86 debug
//代码可以打印出"Hello World"
```

数组只有5个,强行写了6个

数值最后一个元素在[ebp-4]

强行写的arr[6],超出来2个

arr[5]已经超出来,arr[5]是ebp,ebp里面存放了原来的ebp

arr[6]已经超出来,arr[6]是ebp-4,ebp-4存放了push 进去的ip 现在ip被修改为了一个函数的地址

于是就可以运行

```
  push    ebp
  mov     ebp, esp
  sub     esp, 20h
  mov     dword ptr [ebp-20], 1
  mov     dword ptr [ebp-16], 2
  mov     dword ptr [ebp-12], 3
  mov     dword ptr [ebp-8], 4
  mov     dword ptr [ebp-4], 5
  mov     eax, offset __Z9HelloWordv; HelloWord(void)
  mov     [ebp+4], eax
  leave
  retn
```

# 缓冲区溢出修改其它变量

用不休止的hello world

```
 #include<stdio.h>
//exe会  用不休止的hello world
 void Fun()
 {
     int i;
     int arr[5] = {0};
     for(i=0;i<=5;i++)
     {
         arr[i] = 0;
         puts("Hello World!...");
     }
 }
 int main()
 {
     Fun();
 }
 
```

```
                  push    ebp
                  mov     ebp, esp
                  sub     esp, 38h
                  mov     dword ptr [ebp-32], 0
                  mov     dword ptr [ebp-28], 0
                  mov     dword ptr [ebp-24], 0
                  mov     dword ptr [ebp-20], 0
                  mov     dword ptr [ebp-16], 0
                  mov     dword ptr [ebp-12], 0
                  jmp     short loc_40154D
; ---------------------------------------------------------------------------
 
  loc_401532:; CODE XREF: Fun(void)+51↓j
                  mov     eax, [ebp-12]
                  mov     dword ptr [ebp+eax*4-32], 0
                  mov     dword ptr [esp], offset Buffer; "Hello World!..."
                  call    _puts
                  add     [ebp+i], 1
 
  loc_40154D:; CODE XREF: Fun(void)+30↑j
                  cmp     [ebp+i], 5
                  jle     short loc_401532
                  leave
                  retn
```

通过arr数组缓冲区溢出,修改了变量i,最后又再一次为0

# gets内存越界

内存越界

```
 #include <stdio.h>
 
 int main( )
 {
     char str[5];
     char a;
 
     printf( "Enter a value :");
     fgets( str,5,stdin );
//gets(str);
 
     printf( "result: \n");
     puts( str );
     printf("a: %c \n",a);
     return 0;
 }
```

输出

```
 Enter a value :123456789
 result:
 1234
 a: x
```