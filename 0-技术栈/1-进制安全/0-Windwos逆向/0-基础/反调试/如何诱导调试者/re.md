# 如何诱导调试者

这个板块起源于我对某个CTF题目的见解

什么是反反调试,,,听上去很高大上,,,,其实...我对它的理解比较浅薄

比如你对某个反调试技术不太了解,,,,

计算你看出那里有反调试,,,,,但是,,,你不知道调试的时候处于哪一个状态

非调试的时候又处于哪个状态....就会晕头转向

因为IDA,xdbg,od等等工具的原因,有些反调试技术真还不好猜测到底处于什么状态

# 基于STARTUPINFO的思考

比如下面这个代码

```
#include <Windows.h>
#include <stdio.h>

int dbg_check()
{
	STARTUPINFO si;
	si.cb = sizeof(si);
	GetStartupInfo(&si);

	if (
		(si.dwX != 0) ||
		(si.dwY != 0) ||//这个可能会变
		(si.dwXCountChars != 0) ||
		(si.dwYCountChars != 0) ||
		(si.dwFillAttribute != 0) ||
		(si.dwXSize != 0) ||//这个可能会变
		(si.dwYSize != 0) ||//这个可能会变
		(si.dwFlags & STARTF_FORCEOFFFEEDBACK)
		)
	{
		printf("我现在在cmd启动的,别人通常会认为我是调试的时候启动\n");
	}
	else
	{
		printf("只要不是cmd启动,我对会进入...别人以为非调试才能进入\n");
    }
	return 0;
}
int main(int argc, char* argv[])
{
	dbg_check();
	return 0;
}
```

关于STARTUPINFO si;那几个成员的返回值

IDA调试的时候的返回值

```
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
```

vs 运行的时候的返回值

```
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
```

vs调试的时候的返回值

```
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
```

终端运行的时候的返回值

```
00000000
00000001
00000000
00000000
00000000
00000064
00000064
00000000
```

所以,通过返回值,我们可以把做题状态分为2种

1) 在cmd运行,检查flag正确

2) 点击运行,或者调试运行,

为什么分为这2类?

如果遇到有反调试的东西,

最好的检测方法就是不动它,

在cmd终端输入信息,然后看结果

为什么不是直接点击运行?因为就算有输出,也停不下来呀....一闪而过

# 其它例子

其它例子就是我们之前使用失败的例子

就是无论怎么搞,他都会进入某个分支,,,,,,所以我之前就把他分类为失败的反调试技术

到现在来看,,,,其实他还是大有用处的

就是用来围魏救赵....