# 热补丁技术( 貌似过时了,但值得学习)

# 介绍

对代码以前NewCreateProcessA()函数的结构简单梳理如下：

```jsx
NewCreateProcessA(...)
{
    //①脱钩 unhook
    
    //②调用 原始API 
    
    //⑤操作
    
    //④挂钩 hook
}
```

一个线程尝试运行某段代码时，若另一进程正在对该段代码进行“写”操作，

这时就会出现冲突，最终引发运行时错误。所以我们需要一种更安全的API钩取技术。

《Windows核心编程》一书中曾指出，运用代码修改技术钩取API会对系统安全造成威胁。

讲解“热补丁”技术前，先看看常用x86 API 的起始代码部分

![Untitled](%E7%83%AD%E8%A1%A5%E4%B8%81%E6%8A%80%E6%9C%AF(%20%E8%B2%8C%E4%BC%BC%E8%BF%87%E6%97%B6%E4%BA%86,%E4%BD%86%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0)%20ad66c2b6b5064fa297f278ef8c89ee15/Untitled.png)

API开头部分是 

mov edi,edi 占用2字节

然后前面会有5字节nop

首先我们得知道mov edi,edi是一句废话

然后为什么API前面会有5个nop

用下面的图解释一下

![Untitled](%E7%83%AD%E8%A1%A5%E4%B8%81%E6%8A%80%E6%9C%AF(%20%E8%B2%8C%E4%BC%BC%E8%BF%87%E6%97%B6%E4%BA%86,%E4%BD%86%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0)%20ad66c2b6b5064fa297f278ef8c89ee15/Untitled%201.png)

可以看出,其实左边的机制是为了方便右边的东西

同时这种机制还方便了我们, 不需要先脱钩,然后调用原函数,然后挂钩

为什么这样说?

以前调用原函数之所以要脱钩

1), 防止出现死循环调用

2), 保持原函数的完整性

现在这种热补丁机制的话

1), 不会出现死循环的调用,理由见下面

2), 不需要脱钩,  在调用原函数的时候,不用直接call Target_API,而是 call (Target_API+2)就可以实现原函数的完整调用,还不会出现死循环

这种东西(机制)看上去很好

但是… 目前发现自己的API没有这些机制

没有所谓的nop,也没有所谓的mov

# 可以采纳的地方

虽然目前很多dll都不支持这些技术

但是还是可以采纳他的思想

比如为什么使用热补丁技术: 其中之一就是防止hook和unhook频繁的写入和更新

![Untitled](%E7%83%AD%E8%A1%A5%E4%B8%81%E6%8A%80%E6%9C%AF(%20%E8%B2%8C%E4%BC%BC%E8%BF%87%E6%97%B6%E4%BA%86,%E4%BD%86%E5%80%BC%E5%BE%97%E5%AD%A6%E4%B9%A0)%20ad66c2b6b5064fa297f278ef8c89ee15/Untitled%202.png)

比如常见的API,我们可以把他们cv到自己的用户区域

然后设置类似于一些热补丁机制的硬编码

比如jmp到我们的API

如果要直接调用原函数的话,就直接call y就可以了,也不需要hook和unhook

<aside>
💡 cv原始API的时候,还得注意重定位的一些东西

</aside>