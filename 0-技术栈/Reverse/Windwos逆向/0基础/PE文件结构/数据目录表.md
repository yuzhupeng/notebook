# 数据目录表

一般情况下,一共占有0x80个

一个8字节,16个就是hex(8*16)=0x80

# [01] 导入表

导出数据所在的节通常名字是.idata

数据目录表中一共有4中类型和导入表有关

1. 导入表 Import
2. 导入函数地址表 IAT
3. 绑定导入表
4. 延迟加载导入表

每个导入表都是结构体,这些结构体连续分布

每一个要导入的dll结构体也具体指向了很多具体的数据

在DIY创建导入表的时候,说IAT和INT表至少8字节才算有效

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled.png)

## struct

x86

```c
struct _IMAGE_IMPORT_DESCRIPTOR
{
    0x00 union
     {
         0x00        DWORD Characteristics;
         0x00        DWORD OriginalFirstThunk;
         //INT 指向一个数组,数组成员是指针,以0结尾,指针又指向一个结构体
         //如果数组成员是0x80000xxxx----,表示他为序号导入
         //否则为名称导入,OriginalFirstThunk指向的是函数的名字,那么指向的结构应该为{Hint+Name}的结构
     } u;
    0x04 DWORD  TimeDateStamp;
    //无用 当时间戳=0,表示dll的地址没有被绑定 ,
    //否者表示dll的地址被绑定了
    0x08 DWORD  ForwarderChain;     //无用
    0x0c DWORD  Dll_Name;//指向dll字符串的RVA ,0结尾,导入dll的时候,可以不要.dll后缀名
    0x10  DWORD FirstThunk;//IAT,以0结尾,
};
```

现在有个问题, Dll_Name指向的是W版本字符串还是A版本字符串

## 关于 OriginalFirstThunk | FirstThunk

关于INT

关于IAT

在exe没加载之前,IAT和INT类似

在exe加载后,数据INT和IAT出现不同

1 他们分别指向一个不同的数组,但是数组的内容是相同的,比如数组成员都指向函数的名字(字符串)

2 在模块加载后,FirstThunk指向的数组,内容不在和OriginalFirstThunk一致,而是指向W具体的函数

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%201.png)

## call xx?

比如

FF 15 98 B0 41 00       call    *(ds:MessageBoxA)   ;其实就是call *(指针)

其中 98 B0 41 00-> 0040B098其实就是FirstThunk指向的那个数组的某个成员

而0040B098指向的那个地址,也就是MessageBoxA真正的地址

0040B098指向什么? 看下面

```
.idata:0041B098 C0 17 E6 76             MessageBoxA dd offset user32_MessageBoxA
 .idata:0041B098                                                                 ; CODE XREF: _main_0+31↑p
 .idata:0041B098                                                                 ; DATA XREF: _main_0+31↑r ...
 .idata:0041B09C 00 00 00 00 00 00 00 00
 .idata:0041B09C 00 00 00 00 00 00 00 00
```

可以看出0041B098指向的地址就是C0 17 E6 76 ,也就是76E617C0,就是真真函数的地址

```
USER32.dll:76E617C0 8B FF                   mov     edi, edi
 USER32.dll:76E617C2 55                      push    ebp
 USER32.dll:76E617C3 8B EC                   mov     ebp, esp
 USER32.dll:76E617C5 83 3D 94 6C E8 76 00    cmp     dword_76E86C94, 0
 USER32.dll:76E617CC 74 22                   jz      short loc_76E617F0
```

## 导入表那么多个

什么时候结束??

当成员的struct _IMAGE_IMPORT_DESCRIPTOR.Dll_Name字段是0就结束..而不需要整个结构体全部为0

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%202.png)

所以我们就可以把其它部分赋值为任意值,然后只把Dll_Name赋值为0

通常情况下OriginalFirstThunk和FirstThunk指向相同的数据内容,

我们称这种为双桥结构的导入表,也就是通过OriginalFirstThunk和FirstThunk

我们都可以遍历到INT

还有一种情况是只有FirstThunk指向了INT,此刻称之为单桥结构,这种结构不可以绑定导入表

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%203.png)

关于为什么会有OriginalFirstThunk和FirstThunk指向了相同的数据内容,

而且你还觉得很啰嗦...

如果只有FirstThunk,当PeLOad后,之前的函数名称的指针数组就丢失了,

数组的内容被替换为函数的地址VA

那么就不再还有指针数组指向

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%204.png)

当然,如果孤掷一注的话,我门也不需要有谁指向这个名称数组\

时间戳

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%205.png)

不太理解这句话

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%206.png)

不太理解这句话

然后我发现

不同的简单的2个exe去调用MessageBox的API的时候

他们的函数地址都是一样的....!!!!!!

# [12] IAT 导入函数地址表

准确的说他是导入表的一部分

它指向了某个dll的IAT(FirstThunk)

第一次我发现是kernel32

PE文件中所有导入函数jmp指令操作数的集合，组成了另外一个数据结构，

这个结构就是导入函数地址表( Import Address Table，IAT)。该地址表是数据目录的第13个数据目录项。

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%207.png)

# [11] 绑定导入表

```
typedef struct _IMAGE_THUNK_DATA
{
    union
     {
         PBYTE ForwarderString;
         PDWORD Function;      //被导入的函数的入口地址
         DWORD Ordinal;       // 该函数的序数
         PIMAGE_IMPORT_BY_NAME AddressOfData;   // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME
     }u1;
} IMAGE_THUNK_DATA32;
```

```
struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;
```

绑定导入表 成员

```
struct _IMAGE_BOUND_IMPORT_DESCRIPTOR
{
    DWORD   TimeDateStamp;//时间戳

    WORD    OffsetModuleName;//指向dll的名字

    WORD    NumberOfModuleForwarderRefs;//对应成员的数目
    // 表示该动态链接库中的函数实现字节码存储在另外一个动态链接库中
} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;
```

有无绑定导入表是根据导入表的时间戳来判断的

绑定导入表一般位于0x400以内的地方,也就是section header 结束之后

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%208.png)

TimeDateStamp

该字段的值必须与要引用的DLL的文件头IMAGE_FILE_HEADER.TimeDateStamp字段值相吻合，

否则就会促使加载器去重新计算新IAT，这种情况一般发生在DLL版本不同时或者DLL映像被重定位时

OffsetModuleName

该地址既不是RVA,也不是VA

是一个基于绑定导入表起始地址的偏移量

比如绑定导入表的地址是0x250

OffsetModuleName=0x30

那么对应dll的名字就在0x280

# [00] 导出表

## 说明

导出数据所在的节通常名字是.edata

rdata也可以存储相关信息

export.size无用

导出表的作用有两个:

一是可以通过导出表分析不认识的动态链接库文件所能提供的功能。

二是向调用者提供输出函数指令在模块中的起始地址

一般情况下,DLL是导出,exe是导入

当然Dll也可以导入,exe也可以导出

```c
struct _IMAGE_EXPORT_DIRECTORY
{
    DWORD   Characteristics;    //未使用 导出表的特征标志，一般为0
    DWORD   TimeDateStamp;      //时间戳 导出表的创建时间戳。
    WORD    MajorVersion;       //未使用 导出表的主版本号
    WORD    MinorVersion;       //未使用 导出表的次版本号。

    DWORD   Name;               //字符串指针 dll的名字
    DWORD   Base;               //基址编号 导出表中所有函数的序号起始值，默认为1
    DWORD   NumberOfFunctions;  // 导出表中的导出函数数量,其中是有空函数的
    DWORD   NumberOfNames;      // 导出表中有字符串名称的导出函数数量
    DWORD   AddressOfFunctions;     // dword数组, 实际函数的RvA数组 导出表中所有导出函数
    DWORD   AddressOfNames;         // dword数组 导出表中所有有名称的导出函数的名称
    DWORD   AddressOfNameOrdinals;  // word数组  导出表中所有有名称的导出函数序号
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```

如果用名称导入,那么查表就会用到AddressOfFunc,AddressOfOrdianl,AddressOfFunc

如果用序号导入,就只用Base和,AddressOfFunc

函数GetProAddress

```c
FARPROC GetProcAddress(
  [in] HMODULE hModule, // DLL模块句柄
  [in] LPCSTR  lpProcName   // 函数名
);
```

NumberOfFunctions >= NumberOfNames 有些函数是没有名字的

Base: 就是一个基地址,好比于我么每一section的起始地址, 某个函数2编号都要加上base才是真是的编号

AddressOfNames和AddressOfNameOrdinals在地址上是一一对应的

每个有名字的函数都有一个AddressOfNameOrdinals

关于他的对应函数地址的寻找,也是用 Functions [ Ordinals ] , 并不是 Functions [ Ordinals + base ]

但是,对应没有名字的函数,怎么调用? 我们用Getprocessaddress传入的参数是一个默认的( ID = Ordinals + base)

所以在索引函数的使用是ID-base

所以这就是base的作用了,对传入的编号 ID-base

所以base只在ID编号遍历的时候有用

在名称遍历的时候,没用

从名称遍历导出表,不需要用base

从ID遍历导入表需要用base,实际索引值=ID-base

给dll的地址,然后获取导出表的函数地址

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%209.png)

## 应用

导出表常见的应用主要包括对导出表函数的覆盖，以及对动态链接库内部私有函数的导出等。

通过对导出表函数进行覆盖，可以更改代码流程或代码功能，为应用程序实施补丁;.

通过对动态链接库内部私有函数的导出，可以更充分地利用已有的代码，减轻二次开发的工作量。

下面介绍两种常见的导出函数覆盖技术:

修改导出结构中的函数地址

也就是修改对应坑位的地址

比如某某AddressOfFunctions[xx]为的名字叫做 void makeGirlfriend()

于是你把他的地址修改为void makeBoylfriend(),那么别人在调用的时候

明明交的是女朋友,你却拿一个男朋友过去

在这期间,你得注意调换前后,堆栈的一个平衡问题

覆盖函数地址部分的指令代码

暴力覆盖: 即将所有的代码全部替换为新代码。新代码可能含有原来代码的全部功能，也可能不包含原有代码功能

完美覆盖: 通过构造指令，实施新代码与原代码的共存和无遗漏运行

比如我么的跨段跳转,书上有个实验就是修改某个dll内部的代码实现一个跨段的跳转

在xxx.dll跳转到yyy.dll,并没有用到loadlibiary,并且你还要知道跳转到另外一个dll的哪个位置

# [05] 基址重定位

基址重定位数据所在的节通常名字是.reloc

一般情况下,exe都会加载到ImageBAse,所以不会使用基址重定位

但是如果没有加载到ImageBAse,那么就会存在基址重定位

dll在加载的时候,一般都需要重定位置

各个dll贴在exe的内存中,是挨得比较紧密的,但是各个dll之间会有对齐的行为,默认的对齐是10000h,也就是64k

数据目录表的重定位的size很有用,它决定了有多少地方需要重定位

```
struct _IMAGE_BASE_RELOCATION
{
    DWORD   VirtualAddress;//RVA,代码页,对应数组的其实地址
    DWORD   SizeOfBlock;/成员个数
        // WORD	Arr[1]; 柔性数组
    } IMAGE_BASE_RELOCATION,* PIMAGE_BASE_RELOCATION;
```

每一个代码页都有这样的数据结构

VirtualAddress 决定了代码页的地址

SizeOfBlock 决定了这个数据结构的大小

数组成员个数=(SizeOfBlock-4*2)/2 就是柔性数组的成员个数

关于地址遍历

假设x=arr[xx];

(x&0xF000)>>3是标志位,如果结果是3,表示对应地址的4个字节都要修改,一般情况下,我们的遇到的都是3

(x&0x0FFF)+VirtualAddress 就是需要修改的地方的RVA地址

- ((x&0x0FFF)+VirtualAddress+ImageBase) 就是需要修改的值

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2010.png)

修改的值=新的ImageBase - 旧的 ImageBase+原有的地址

# [02] 资源

资源数据所在的节通常名字是.rsrc

该节是一个多层的二叉树

struct IMAGE_DATA_DIRECTORY

资源表是一个比较复杂的结构,然后也不太会用它,

除非你想要把恶意数据写入资源表...但是

我们为什么不可以把恶意数据写入图片,然后把图片加载到恶意成语当中呢

总之办法很多,不到最后,就不忙学习资源表的东西吧

API

更新PE文件资源的: BeginUpdateResource、UpdateResource、EndUpdateResource。

遍历PE文件的资源: EnumResourceTypes、EnumResourceNames、EnumResourceLanguages。

# [13] 延迟导入表

https://blog.csdn.net/evileagle/article/details/12718845

和dll加载有关

以前dll的加载是,有很多dll干活,把所有dll都喊进屋,到谁干活谁就出来, ps:屋子可能不太好装下怎么多人

延迟导入就是准备很多dll干活,不先把他们领进门,让他们所有人在外面等着,干活时,喊谁,谁就进来

延迟加载导入是一种合理利用进程加载机制提高进程加载效率的技术，

使用延迟加载导入能跳过加载前对引入函数的检测及加载后对IAT的修正，

从而避免出现诸如“无法找到组件”的错误提示，提高程序的适应性。

及时即用?

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2011.png)

```
typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR
{
    union {
        DWORD AllAttributes;// 属性,说必须为0
        struct
        {
            DWORD RvaBased : 1;             // Delay load version 2
            DWORD ReservedAttributes : 31;
        } DUMMYSTRUCTNAME;
    } Attributes;

    DWORD DllNameRVA;                       // 指向dll的名字,好像是一个VA地址
    DWORD ModuleHandleRVA;                  // 指向dll的模块句柄
    DWORD ImportAddressTableRVA;            // IAT
    DWORD ImportNameTableRVA;               // INT
    DWORD BoundImportAddressTableRVA;       // 绑定该表的RVA 可选
    DWORD UnloadInformationTableRVA;        // 卸载该表的RVA 可选
    DWORD TimeDateStamp;                    // 0 if not bound,
    // Otherwise, date/time of the target DLL

} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;
```

不使用延迟加载

```
ml -c -coff He1loworld.asm
link -subsystem : windows Hellowor1d.obj
He1loworld
```

使用延迟加载

```
ml -c -coff Helloworld.asm
link -subsystem:windows -delayload:MyD11.dll delayimp.lib HelloWorld.obj
Helloworld
```

那么link -subsystem:windows -delayload:MyD11.dll delayimp.lib HelloWorld.obj干了什么?

首先，将一个函数_delayLoadHelper嵌入PE文件的可执行模块。

其次，从可执行模块的导入表部分删除MyDl.dll 及相关信息，这样，当进程初始化的时候，

操作系统的加载程序就不会显式加载该动态链接库了。

最后，在PE中把刚才删除的相关信息重新构造好，以便告诉_delayLoadHelper哪些函数是从MyDll.dll中导出的。

在调用API的时候

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2012.png)

然后出现就出现了区别

不使用该技术就直接前往该dll

使用该技术,去往某个函数,然后LoadLibiary和GetProcessAddress,如果再次调用不再load和get

为什么使用了延迟导入表技术可以实现任何地方都可以轻松运行?

因为他把dll文件作为资源放进了自己那里,然后需要的时候再调用资源?

关于这个书中有代码讲解,我没有去实现,,,,QWQ,还是去写一下吧,万一有用呢

关于延迟导入的dll卸载,可以使用-delay:unload选项

这是一个可选项,具体深入还不知道

# [09] TLS

```c
typedef VOID
(NTAPI *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;         // PDWORD
    ULONGLONG AddressOfCallBacks;     // PIMAGE_TLS_CALLBACK *;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    DWORD   AddressOfIndex;             // PDWORD
    DWORD   AddressOfCallBacks;         // PIMAGE_TLS_CALLBACK *
    DWORD   SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;
```

https://www.cnblogs.com/LyShark/p/13525917.html

```
typedef struct _IMAGE_TLS_DIRECTORY32
{
    DWORD   StartAddressOfRawData;	//文件主线程局部存储tls的起点,VA
    DWORD   EndAddressOfRawData;	//文件主线程局部存储tls的终点,VA
    DWORD   AddressOfIndex;          //tls索引位置
    DWORD   AddressOfCallBacks;     //指针数组,成员是回调的函数,以NULL结尾
    DWORD   SizeOfZeroFill;			//填充0的个数,
    DWORD   Characteristics;		//保留 0xCCCCCCCC
} IMAGE_TLS_DIRECTORY32;
```

基址重定位需要考虑到tls的VA修改

加载的时候,文件[ StartAddressOfRawData, EndAddressOfRawData]的数据会被复制到堆区去

TLS数据所在的节通常名字是.tls

它实现了线程内局部变量的存储访问

__declspec (thread) int  g_nNum = 0;

多线程访问全局变量 g_nNum ,得到的数据一直是0开始,无论其它线程怎么对 g_nNum 修改

int  g_nNum = 0;

多线程访问全局变量 g_nNum ,得到的数据不一定是0开始,因为其它线程可能对它做了一个修改

相当于tls拷贝g_nNum给任意一个子线程,让他们独自享用

内核模式创建进程

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2013.png)

一个进程的创建涉及很多东西,但是,没有线程的进程就是一滩死水

内核创建一个线程

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2014.png)

我想说的是,一个线程,进程的创建是一个蛮复杂的过程,所以搞清楚每一步才好设置一些陷阱

详细信:详细信息参考潘爱名老师的<<windows内核原理与实现

TLS技术分为两种:

动态线程局部存储技术

静态线程局部存储技术

TLS技术的分类主要依据是﹔线程局部存储的数据所用空间在程序运行期，操作系统完成的是动态申请还是静态分配。

动态线程局部存储通过四个Win32 API函数实现对线程局部数据的存储﹔

而静态线程局部存储则通过预先在PE文件中声明数据存储空间，由PE加载器加载该PE进入内存后为其预留存储空间实现。

## 动态线程局部存储技术

有一个TLS数组在结构体PEB中,

arr[64]

同时有一个8字节,64bit,记录了数组成员每一位是否被使用

unsigned long long

DWORD TlsAlloc(VOID)();

函数成功返回一个索引值值,失败返回-1

一旦函数返回成功,对应8字节那个bit位就变为1

DWORD TlsGetValue(DWORD index);

成功就返回对应的值,失败就返回0,当然里arr[]的值本来就可以是0,所以失败还需进行getlasterror进一步判断

BOOL SetTlsValue(DWORD index,LPVOID lpTlsValue)

失败返回0,成功不返回0

BOOL TlsFree(DWORD index);

失败返回0,成功不返回0,并把对应位置为0

如果如果arr[]装的是你自己申请的内存,那么也得是你自己释放,而不是tlsfree释放

```
#include<Windows.h>
#include <stdio.h>

DWORD WINAPI MY_ThreadProc(LPVOID);
DWORD32 MY_GetValue(DWORD32);

int main()
{
    HANDLE gh_tmp=0;
    gh_tmp = CreateThread(0, 0, MY_ThreadProc, 0, 0, 0);
    WaitForSingleObject(gh_tmp, 0xffffffff);
    system("pause");
    return;
}

DWORD WINAPI MY_ThreadProc(LPVOID lp_Param)
{
    DWORD32 dw_tmp = 0, index = 0;
    index = TlsAlloc();
    TlsSetValue(index, (LPVOID)0x1234);
    dw_tmp = TlsGetValue(index);
    printf("%08X\n", dw_tmp);
    TlsFree(index);
    return 0;
}
```

## 静态线程局部存储技术

就是手动在源代码写入数据

```
#pragma comment(linker, "/INCLUDE:__tls_used")

// TLS变量
__declspec (thread) int  g_nNum = 0x64;
__declspec (thread) char g_szStr[] = "TLS g_nNum = 0x%p ...\r\n";

//如果要写入函数的话
// 注册TLS回调函数，".CRT$XLB"
#pragma data_seg(".CRT$XLB")
PIMAGE_TLS_CALLBACK p_thread_callback[] = { TLS_A, TLS_B};
#pragma data_seg()
```

## TLS回调函数

void NTAPI TLS_B(PVOID DllHandle, DWORD Reason, PVOID Red);

参数解释:

1. Reserved:预留，为0。
2. Reason:调用该回调函数的时机
3. DllHandle:DLL的句柄。

标准的tls,了解一下

```
void NTAPI TLS_B(PVOID DllHandle, DWORD Reason, PVOID Red)
{
    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
            printf("Process Attach\n");
            break;
        case DLL_PROCESS_DETACH:
            printf("Process Detach\n");
            break;
        case DLL_THREAD_ATTACH:
            printf("Thread Attach\n");
            break;
        case DLL_THREAD_DETACH:
            printf("Thread Detach\n");
            break;
        default:
            break;
    }
    return;
}
```

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2015.png)

在主线程加载的时候,主线程会把所有tls调用个遍,调用的理由Process Attach

奇怪的是,我的主线程结束的时候,并没有调用tls,

主线程如果创建了子线程,那么也会调用所有tls函数,调用理由Thread Attach

子线程结束的时候,那么也会调用tls函数,调用理由Thread Detach

写入tls函数

```
#include <Windows.h>
#include <stdio.h>
#pragma comment(linker, "/INCLUDE:__tls_used")

//然后巴拉巴拉注册
#pragma data_seg(".CRT$XLB")
PIMAGE_TLS_CALLBACK p_thread_callback[] = { TLS_B, TLS_A};
#pragma data_seg()

VOID _stdcall TLS_A(PVOID DllHandle, DWORD Reason, PVOID Reserved);
VOID _stdcall TLS_B(PVOID DllHandle, DWORD Reason, PVOID Reserved);
//然后巴拉巴拉
int main()
{

}
VOID _stdcall TLS_A(PVOID DllHandle, DWORD Reason, PVOID Reserved)
{

}
VOID _stdcall TLS_B(PVOID DllHandle, DWORD Reason, PVOID Reserved)
{

}
```

另外一种奇奇怪怪的写入

```
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include < Windows.h>

#pragma section(".CRT$XLY", long, read)
__declspec(thread) int var = 0xDEADBEEF;

VOID _stdcall TlsCallback(PVOID DllHandle, DWORD Reason, PVOID Reserved)
{
    var = 0xB15BADB0; // Required for TLS Callback call
    if (IsDebuggerPresent())
    {
        MessageBoxA(NULL, "Stop debugging program!", "Error", MB_OK | MB_ICONERROR);
        TerminateProcess(GetCurrentProcess(), 0xBABEFACE);
    }
}
__declspec(allocate(".CRT$XLY")) PIMAGE_TLS_CALLBACK g_tlsCallback = TlsCallback;

int main()
{
    puts("Hello World");
    return 0;
}
```

# [10] 加载配置表 | 异常处理表

根据自己写的exe,发现好像那个表没什么明显的用处

书上讲了很多和内核相关的东西,暂时看不懂(也就是和内核的一些关键函数和流程的分析)

和SEH有关:

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2016.png)

ExceptionList:

![Untitled](%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8%207dd3496d4e184434a98edc11de043e96/Untitled%2017.png)

下面这个表和书上的表有点不同哟

大体相同

```
typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD   Size;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;//主版本号
    WORD    MinorVersion;//次版本号
    DWORD   GlobalFlagsClear;//标志1 需要被清除的
    DWORD   GlobalFlagsSet;//标志2 需要被初始化的
    DWORD   CriticalSectionDefaultTimeout;//最大超时限制
    DWORD   DeCommitFreeBlockThreshold;//释放内存数量
    DWORD   DeCommitTotalFreeThreshold;//空闲内存数量
    DWORD   LockPrefixTable;                // VA 使用locl前缀的指令地址
    DWORD   MaximumAllocationSize;//最大分配粒度
    DWORD   VirtualMemoryThreshold;//最大虚拟内存大小
    DWORD   ProcessHeapFlags;//进程堆标志
    DWORD   ProcessAffinityMask;//函数参数
    WORD    CSDVersion;//版本标识
    WORD    DependentLoadFlags;
    DWORD   EditList;                       // VA cookies指针
    DWORD   SecurityCookie;                 // VA 指向safe handler 处理程序列表
    DWORD   SEHandlerTable;                 // VA
    DWORD   SEHandlerCount;//safe handler
    DWORD   GuardCFCheckFunctionPointer;    // VA
    DWORD   GuardCFDispatchFunctionPointer; // VA
    DWORD   GuardCFFunctionTable;           // VA
    DWORD   GuardCFFunctionCount;
    DWORD   GuardFlags;
    IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    DWORD   GuardAddressTakenIatEntryTable; // VA
    DWORD   GuardAddressTakenIatEntryCount;
    DWORD   GuardLongJumpTargetTable;       // VA
    DWORD   GuardLongJumpTargetCount;
    DWORD   DynamicValueRelocTable;         // VA
    DWORD   CHPEMetadataPointer;
    DWORD   GuardRFFailureRoutine;          // VA
    DWORD   GuardRFFailureRoutineFunctionPointer; // VA
    DWORD   DynamicValueRelocTableOffset;
    WORD    DynamicValueRelocTableSection;
    WORD    Reserved2;
    DWORD   GuardRFVerifyStackPointerFunctionPointer; // VA
    DWORD   HotPatchTableOffset;
    DWORD   Reserved3;
    DWORD   EnclaveConfigurationPointer;    // VA
    DWORD   VolatileMetadataPointer;        // VA
    DWORD   GuardEHContinuationTable;       // VA
    DWORD   GuardEHContinuationCount;
    DWORD   GuardXFGCheckFunctionPointer;    // VA
    DWORD   GuardXFGDispatchFunctionPointer; // VA
    DWORD   GuardXFGTableDispatchFunctionPointer; // VA
    DWORD   CastGuardOsDeterminedFailureMode; // VA
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;
```

# [03] 异常表

异常表数据所在的节通常名字是.pdata

可选文件头的Exception Table指向它

该节是用于异常处理函数表项组成的数组

# [04] 属性证书数据表

类似于PE文件的校验或者MD5值

```
addr: 它的值是FA,不会映射到内存
size:
```

# [06] 调试信息地址表

调试信息数据所在的节通常名字是.debug

这就是为什么你用IDA调试,他妈出现了源码文件

# [07] 预留

必须为0

# [08] 全局指针寄存器表

描述的是被存储在全局指针寄存器的一个值

# [14] CLR运行头

CLR运行头数据所在的节通常名字是.cormeta

# [15] 系统保留