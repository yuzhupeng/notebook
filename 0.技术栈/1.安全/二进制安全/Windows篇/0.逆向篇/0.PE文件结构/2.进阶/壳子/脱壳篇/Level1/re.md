寻找特征指令

```assembly
pushad
popad
jmp大跳转
```



# UPX



## 32位

![image-20230801202154927](img/image-20230801202154927.png)

也就是类似于一个文本搜索的CTRL F指令

搜索特征码

```
pushad
popad
jmp大跳转
```

找到后下断点



### 搜索特征码

> xdbg搜索 CTRL F

![image-20230801185640746](img/image-20230801185640746.png)

找打后下断点

搜索结果

![image-20230801185706484](img/image-20230801185706484.png)

下断点

![image-20230801185755467](img/image-20230801185755467.png)



下断点后,jmp过去就是OEP

然后就是利用插件脱壳



> OD搜索 CTRL F

![image-20230801201735572](img/image-20230801201735572.png)

然后你就找到关键位置去往OEP

下断点后,jmp过去就是OEP

然后就是利用插件脱壳



### x32_OD :  插件脱壳 



![image-20230801104020891](img/image-20230801104020891.png)

在OEP: 004010B0右键一下

![image-20230801104145717](img/image-20230801104145717.png)

然后

![image-20230801104217840](img/image-20230801104217840.png)

分别选取方法1/方法2点击脱壳

2个方法都试一下,可能有些方法不行





### x32_dbg : Scylla脱壳

一样的运行到OEP,打开x64dbg自带的插件Scylla

![image-20230801110958472](img/image-20230801110958472.png)

#### step1

点击它

![image-20230801110928596](img/image-20230801110928596.png)

然后点击dump

ps: 一般插件的OEP和输出文件自动填写完毕

ps: 输出文件不是最后的成品,还需要修复



#### step2

不关闭Scylla

继续操作插件



ps: 然后保证插件的高级搜索是打开的,一般都是打开的,所以下面这个图片不用看

![image-20230801111240466](img/image-20230801111240466.png)

点击2下, 

![image-20230801111429687](img/image-20230801111429687.png)

注意点击fixdump的时候,需要选择一个文件

该文件是step1 dump出来的文件

最后运行成功

![image-20230801111651889](img/image-20230801111651889.png)

## 64位

![image-20230801202217599](img/image-20230801202217599.png)

借助 IDA+ x64dbg 脱壳

当然他的特征还是那些 pushad,popad,jmp大跳转

但是x64没有类似于些pushad,popad的指令吧

至少我没有遇到过

所以jmp大跳转就是唯一的特征

当然 pushad,popad 与之取代的是push很多下,pop很多下

IDA结合x64dbg

他的起始流程图也和x86不一样

![image-20230801133932326](img/image-20230801133932326.png)



进入函数`UPX1:00007FF72543C2CB call    sub_7FF72543C320`看看

![image-20230801134116446](img/image-20230801134116446.png)

![image-20230801134048325](img/image-20230801134048325.png)

在rep retn的地方,我们会进入一个和x86下差不多的环境

那里有大跳转的特征

ps: 可能我们遇到的流程图或者平坦化图有差异,但是那些特征是不变的

当我们在IDA里面都清楚了这些地方了

去x64dbg进行Scylla脱壳还是一样的操作

参考前面的步骤,实践发现可行





# Aspack



## x86



![image-20230801202132841](img/image-20230801202132841.png)



### xdbg

![image-20230801202815225](img/image-20230801202815225.png)

然后搜索popad ->CTRL F

搜索结果

![image-20230801202902788](img/image-20230801202902788.png)

那就都在对应的地方下断点,

![image-20230801202929286](img/image-20230801202929286.png)

然后F9,会在某一个popad停止下来,然偶通过ret去玩OEP

![image-20230801203310233](img/image-20230801203310233.png)

 修复后运行成功

![image-20230801203455004](img/image-20230801203455004.png)

### OD

![image-20230801202445079](img/image-20230801202445079.png)

一样有pushad

所以我们寻找与之对应的popad,直接CTRL F

ps: 它不会像xdbg那样把所有的popad罗列出来, 只能说CTRL F, 每次CTRL F都会去查下一个popad的搜索结果

有些鸡肋的OD, 只能搜一个,,,垃圾

![image-20230801203648720](img/image-20230801203648720.png)



