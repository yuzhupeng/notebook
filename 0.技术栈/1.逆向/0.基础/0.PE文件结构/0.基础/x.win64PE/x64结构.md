# x64结构

# DOS_HEADER

struct IMAGE_DOS_HEADER DosHeader

这个结构是一样的,大小 4x16

# NT_HEADERS

struct IMAGE_NT_HEADERS NtHeader

差异就在于选项头

```c
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;//64位
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;//32位
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

## FILE_HEADER

struct IMAGE_FILE_HEADER FileHeader

这个结构是一样的,大小 4x5

对于x64的 `WORD SizeOfOptionalHeader`  该值一般是240=0xF0字节

对于x86的 `WORD SizeOfOptionalHeader` 该值一般是224=0xE0字节

```c
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

## OPTIONAL_HEADER64

struct IMAGE_OPTIONAL_HEADER64 OptionalHeader x64的

struct IMAGE_OPTIONAL_HEADER32 OptionalHeader x86的

从这里开始,就发生了一些变化,因为涉及一些地址的东西了

```c
typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
		//无DWORD BaseOfData;
    ULONGLONG   ImageBase; //变为了8字节
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;//变为了8字节
    ULONGLONG   SizeOfStackCommit;//变为了8字节
    ULONGLONG   SizeOfHeapReserve;//变为了8字节
    ULONGLONG   SizeOfHeapCommit;//变为了8字节
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];//内部的 VirtualAddress 和 Size 大小没变
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
```

从地址上来说,x64的多了4x5的字节,就是20字节

但是x64的结构少了一个`DWORD BaseOfData;` 所以总体来说,会比x86的大小多16字节

ps: IMAGE_DATA_DIRECTORY,数据目录表也涉及地址,但是长度没有发生变化, 也就是说他的VA和Size没变,还是



### DataDirArray

[0] 导出表结构是一样的

```nasm
//@[comment("MVI_tracked")]
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
```

对于这几个数组,他的结构没变

```c
    DWORD   AddressOfFunctions;     // RVA from base of image
    DWORD   AddressOfNames;         // RVA from base of image
    DWORD   AddressOfNameOrdinals;  // RVA from base of image
```

只不过AddressOfFunctions装的是dowrd成员,但是指向的确是8字节的空间

其它类推

[1] 对于导入表,他的大小结构是没变的

```nasm
//@[comment("MVI_tracked")]
typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            // 0 for terminating null import descriptor
        DWORD   OriginalFirstThunk;         // RVA to original unbound IAT (PIMAGE_THUNK_DATA)
    } DUMMYUNIONNAME;
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    DWORD   FirstThunk;                     // RVA to IAT (if bound this IAT has actual addresses)
} IMAGE_IMPORT_DESCRIPTOR;
```

但是,对于地址来说,可能发生了变化

因为IAT表存储的是真实函数的内存地址

所以

x64而言就是8字节, INT,IAT是 QWORD* ,

x86而言就是4字节, INT,IAT是 WORD* ,

然后INT和IAT也是类似的

# SectionHeaders

大小结构也没发生变化

```c
typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```