# RVA_FA地址转化



x64版本

```c
#include <windows.h>
#include <stdio.h>


PIMAGE_SECTION_HEADER gSectionHeader;
PIMAGE_NT_HEADERS64 gNtheader;
DWORD64 gFilesize;
BYTE gxorValue;
BYTE* gfileBase;

//地址转换
DWORD32 VA2FA(DWORD32 RVA)
{
	DWORD64 imagebase = gNtheader->OptionalHeader.ImageBase;
	DWORD64 sizeofimage = gNtheader->OptionalHeader.SizeOfImage;
	int cnt = gNtheader->FileHeader.NumberOfSections;
	int i = 0;
	int ok1, ok2 = 0;
	if (RVA == 0)//不可能是0,但是导出表会传递进来0
		return 0;

	if (RVA >= imagebase)
	{
		RVA -= imagebase;//传递进来的是VA
	}
	//否者传递进来的是FA
	for (i = 0; i < cnt - 1; i++)
	{
		ok1 = RVA >= gSectionHeader[i].VirtualAddress;
		ok2 = RVA < gSectionHeader[i + 1].VirtualAddress;
		if (ok1 && ok2)
		{
			return (RVA - gSectionHeader[i].VirtualAddress + gSectionHeader[i].PointerToRawData);
		}
	}
	if (RVA < sizeofimage)
		return (RVA - gSectionHeader[i].VirtualAddress + gSectionHeader[i].PointerToRawData);
	return -1;
}
//地址转换
DWORD32 FA2VA(DWORD32 FA)
{
	DWORD64 imagebase = gNtheader->OptionalHeader.ImageBase;
	int cnt = gNtheader->FileHeader.NumberOfSections;
	int i = 0;
	int ok1, ok2 = 0;

	for (i = 0; i < cnt - 1; i++)
	{
		ok1 = FA >= gSectionHeader[i].PointerToRawData;
		ok2 = FA < gSectionHeader[i + 1].PointerToRawData;
		if (ok1 && ok2)
		{
			return (FA - gSectionHeader[i].PointerToRawData + gSectionHeader[i].VirtualAddress + imagebase);
		}
	}
	if (FA <= gFilesize)
		return (FA - gSectionHeader[i].PointerToRawData + gSectionHeader[i].VirtualAddress + imagebase);
	return -1;
}

```



x86版本

```c
/**
 * 函数名称：va2fa
 * 函数功能：把传进来的VA转化为FA
 * 输入参数：
 *   - 参数1：VA值
 *   ..
 * 返回值：FA
 * 函数的前提:
 *       需要初始化一下全局变量:
         IMAGE_DOS_HEADER*           lp_Dos;
         IMAGE_FILE_HEADER*          lp_FileHeader;
         IMAGE_OPTIONAL_HEADER64*    lp_option64;
         IMAGE_OPTIONAL_HEADER32*    lp_option32;
         IMAGE_SECTION_HEADER*       lp_SectionHeaders;
 */
DWORD va2fa(DWORD va)
{
    int len;
    int i;
    len = lp_FileHeader->NumberOfSections;
    if (va == -1)
    {
        return -1;
    }
    if (isx86 && va > lp_option32->SizeOfImage)//x86的
    {
        return -1;
    }
    else if (va > lp_option64->SizeOfImage)//x64的
    {
        return -1;
    }

    for (i = 0; i < len - 1; i++)
    {
        if (va >= lp_SectionHeaders[i].VirtualAddress && va <= lp_SectionHeaders[i + 1].VirtualAddress)
        {
            break;
        }
    }
    return va - lp_SectionHeaders[i].VirtualAddress + lp_SectionHeaders[i].PointerToRawData;
}
```





# 导出表



x64遍历

```c
#include <windows.h>
#include <stdio.h>

 
// 获取API函数地址
FARPROC GetFunctionAddress_x64(HMODULE moduleBase, const char* functionName)
{
    // 获取导出表
    IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)moduleBase;
    PIMAGE_NT_HEADERS64 ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)dosHeader + dosHeader->e_lfanew);
    IMAGE_DATA_DIRECTORY* exportDirectory = &(ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]);
    IMAGE_EXPORT_DIRECTORY* exportTable = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)dosHeader + exportDirectory->VirtualAddress);
    // 获取函数名表和函数地址表
    DWORD* arr_AddressOfNames = (DWORD*)((BYTE*)dosHeader + exportTable->AddressOfNames);
    WORD*  arr_AddressOfNameOrdinal = (WORD*)((BYTE*)dosHeader + exportTable->AddressOfNameOrdinals);
    DWORD* Arr_AddressOfFunctions = (DWORD*)((BYTE*)dosHeader + exportTable->AddressOfFunctions);
    int i = 0, j = 0;
    int len_exportedFunctionName;
    // 遍历函数名表
    for ( i = 0; i < exportTable->NumberOfNames; i++)
    {
        const char* exportedFunctionName = (const char*)((BYTE*)dosHeader + arr_AddressOfNames[i]);

        // 比较函数名
        j = 0;
        while (exportedFunctionName[j])
        {
            j++;
        }
        len_exportedFunctionName = j;

        for (j = 0; j < len_exportedFunctionName && functionName[j]; j++)
        {
            if (exportedFunctionName[j] != functionName[j])
            {
                break;
            }
        }
        if (j == len_exportedFunctionName)
        {
            // 获取函数的序号
            WORD functionOrdinal = arr_AddressOfNameOrdinal[i];
            // 获取函数地址
            FARPROC functionAddress = (FARPROC)((BYTE*)dosHeader + Arr_AddressOfFunctions[functionOrdinal]);
            return functionAddress;
        }
    }

    return NULL; // 未找到指定的函数
}

int main()
{
    HMODULE moduleBase = LoadLibraryA("user32.dll");
    if (moduleBase != NULL)
    {
        FARPROC functionAddress = GetFunctionAddress_x64(moduleBase, "MessageBoxA");
        if (functionAddress != NULL)
        {
            // 打印函数地址
            printf("MessageBoxA function address: 0x%p\n", functionAddress);
        }
        else
        {
            printf("Failed to find the specified function.\n");
        }
    }
    else
    {
        printf("Failed to load the DLL.\n");
    }
    FreeLibrary(moduleBase);
    return 0;
}
```





# 导入表



## 遍历问题x64

```c
#include <windows.h>
#include <stdio.h>


PIMAGE_SECTION_HEADER gSectionHeader;
PIMAGE_NT_HEADERS64 gNtheader;
DWORD64 gFilesize;
BYTE gxorValue;
BYTE* gfileBase;

//显示导入表
void showImport()
{
	//dll名字
	int i, j, k;
	DWORD32 imagebase = gNtheader->OptionalHeader.ImageBase;
	PIMAGE_IMPORT_DESCRIPTOR lpImport = VA2FA(gNtheader->OptionalHeader.DataDirectory[1].VirtualAddress) + gfileBase;
	PIMAGE_IMPORT_BY_NAME byname;
	DWORD64* IAT;
	DWORD64* INT;
	BYTE* DllName;
	BYTE* APIName;
	
	HMODULE hDll;

	PIMAGE_NT_HEADERS64 gNtheader_Dll;
	PIMAGE_EXPORT_DIRECTORY lp_Export_Dll;
	DWORD* AddressOfNames;
	WORD* AddressOfNameOrdinals;
	WORD IDbase;
	int numFunc;
	if (gNtheader&&gNtheader->OptionalHeader.DataDirectory[1].VirtualAddress == 0)
	{
		return;
	}
	for (i = 0; lpImport[i].Name; i++)
	{
		DllName = (char*)(VA2FA(lpImport[i].Name) + gfileBase);
		for (k = 0; ; k++)
		{
			DllName[k]^= gxorValue;
			if ( (DllName[k + 1] ^ gxorValue) == 0)
			{
				DllName[k+1] ^= gxorValue;
				break;
			}
		}
	 

		printf("%s\n", DllName);
		hDll = LoadLibraryA(DllName);
		if (1)
		{
			INT = VA2FA(lpImport[i].OriginalFirstThunk) + gfileBase;
			
			for (j = 0; INT[j]; j++)
			{
				if ( INT[j] && ((INT[j] >> 63) == 1))//ID导入
				{
					
					if (hDll)
					{
						gNtheader_Dll = (*(DWORD*)((BYTE*)hDll + 0x3c)) + (BYTE*)hDll;
						lp_Export_Dll = gNtheader_Dll->OptionalHeader.DataDirectory[0].VirtualAddress + (BYTE*)hDll;
						AddressOfNames = lp_Export_Dll->AddressOfNames + (BYTE*)hDll;
						AddressOfNameOrdinals = lp_Export_Dll->AddressOfNameOrdinals + (BYTE*)hDll;
						IDbase = lp_Export_Dll->Base;
						numFunc = lp_Export_Dll->NumberOfFunctions;
						for (k = 0; k < numFunc; k++)
						{
							if ((INT[j] & 0xffff) == AddressOfNameOrdinals[k])
							{
								break;
							}
						}
						if (k != numFunc)
							printf("	%s\n", AddressOfNames[k - IDbase] + (BYTE*)hDll);

					}
					//API_get = hDll+ *(unsigned int*)(hDll+ *(unsigned int*)((char*)&lp_Export->AddressOfFunctions + hDll)+ 4* (*(unsigned __int16*)new_INT- (unsigned __int64)*(unsigned int*)((char*)&lp_Export->Base + hDll)));
				}
				else//名称导入
				{
					byname = VA2FA(INT[j]) + gfileBase;
					APIName = byname->Name;
					for (k = 0; ; k++)
					{
						APIName[k] ^= gxorValue;
						if ((APIName[k + 1] ^ gxorValue) == 0)
						{
							APIName[k + 1] ^= gxorValue;
							break;
						}
					}
					printf("	%s\n", APIName);
				}
				
			}
		}
		FreeLibrary(hDll);
	}
	return;
}
```







## 读取API函数在表中的位置



比如返回MessageBox函数IAT表的位置

方便Hook

```c
/*
* 函数名字: GET_IAT
* 函数参数:
*   WCHAR* dllName dll的名字
*   CHAR* API_Name 要寻找的api名字
* 函数返回值: &IAT[xx];
* 函数功能:
*   返回某个API所在IAT的的指针
*/
VOID* GET_IAT(CHAR* dllName, CHAR* API_Name)//是寻找自己的IAT表
{
    HMODULE selfBase;
    HANDLE  hProcess;
    int x86 = 0;
    DWORD dwPID;
    struct _IMAGE_DOS_HEADER* lp_Dos;
    struct _IMAGE_NT_HEADERS64* lp_NT64;//x64版本
    struct _IMAGE_NT_HEADERS* lp_NT32;//x86版本
    struct _IMAGE_IMPORT_DESCRIPTOR* lp_Imp;

    DWORD64* lp_OriginalFirstThunk64;
    DWORD64* lp_FirstThunk64;

    DWORD* lp_OriginalFirstThunk32;
    DWORD* lp_FirstThunk32;

    int i, j;

    selfBase = GetModuleHandleA(NULL);
    lp_Dos = (struct _IMAGE_DOS_HEADER*)selfBase;

    dwPID = GetCurrentProcessId();
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwPID);
    IsWow64Process(hProcess, &x86);
    CloseHandle(hProcess);

    lp_NT32 = (struct _IMAGE_NT_HEADERS*)(lp_Dos->e_lfanew + (BYTE*)selfBase);
    lp_NT64 = (struct _IMAGE_NT_HEADERS64*)lp_NT32;
    if (x86)
    {
        lp_Imp = (struct _IMAGE_IMPORT_DESCRIPTOR*)(lp_NT32->OptionalHeader.DataDirectory[1].VirtualAddress + (BYTE*)selfBase);
        lp_FirstThunk32 = (DWORD*)(lp_Imp->FirstThunk + (BYTE*)selfBase);
        lp_OriginalFirstThunk32 = (DWORD*)(lp_Imp->OriginalFirstThunk + (BYTE*)selfBase);
    }
    else
    {
        lp_Imp = (struct _IMAGE_IMPORT_DESCRIPTOR*)(lp_NT64->OptionalHeader.DataDirectory[1].VirtualAddress + (BYTE*)selfBase);
        lp_FirstThunk64 = (DWORD64*)(lp_Imp->FirstThunk + (BYTE*)selfBase);
        lp_OriginalFirstThunk64 = (DWORD64*)(lp_Imp->OriginalFirstThunk + (BYTE*)selfBase);
    }
    i = 0;
    j = 0;

    //可我无法确定加载的dll名字是w还是a呀
    while (lp_Imp[i].Name)//是否结束
    {
        //是否相等
        //这dllname 是W版本还是A, 无法确定
        if (!memcmp(lp_Imp[i].Name + (BYTE*)selfBase, dllName, strlen(dllName)))
        {
            if (x86)
            {
                lp_OriginalFirstThunk32 = (DWORD*)(lp_Imp[i].OriginalFirstThunk + (BYTE*)selfBase);
                lp_FirstThunk32 = (DWORD*)(lp_Imp[i].FirstThunk + (BYTE*)selfBase);
                while (lp_OriginalFirstThunk32[j])
                {
                    if (!memcmp(lp_OriginalFirstThunk32[j] + (BYTE*)selfBase, API_Name, strlen(API_Name)))
                    {
                        //找到对应的API索引
                        return &lp_FirstThunk32[j];
                    }
                    j++;
                }
            }
            else
            {
                lp_OriginalFirstThunk64 = (DWORD64*)(lp_Imp[i].OriginalFirstThunk + (BYTE*)selfBase);
                lp_FirstThunk64 = (DWORD64*)(lp_Imp[i].FirstThunk + (BYTE*)selfBase);
                while (lp_OriginalFirstThunk64[j])
                {
                    if (!memcmp(lp_OriginalFirstThunk64[j] + (BYTE*)selfBase, API_Name, strlen(API_Name)))
                    {
                        //找到对应的API索引
                        return &lp_FirstThunk64[j];
                    }
                    j++;
                }
            }
            //是对应的dll

        }
        i++;
    }
    return 0;
}
```



# dump



x64 内存dump到文件

```c
#include <windows.h>
#include <stdio.h>

 
// 获取API函数地址

BYTE* va2fa(BYTE* base,int fileSize)
{  // 获取导出表
    IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)base;
    PIMAGE_NT_HEADERS64 ntHeaders = (IMAGE_NT_HEADERS*)((BYTE*)dosHeader + dosHeader->e_lfanew);
    IMAGE_SECTION_HEADER* secHeader = ntHeaders->FileHeader.SizeOfOptionalHeader + (BYTE*)&ntHeaders->OptionalHeader;
    // 分配内存
    int filsize_new = 0;
    BYTE* pMemory = VirtualAlloc(
        NULL,                   // 指定分配的地址，在此使用 NULL 表示由系统选择
        fileSize,               // 分配的内存大小，与文件大小一致
        MEM_COMMIT,             // 内存分配类型，表示提交内存
        PAGE_READWRITE          // 内存页面属性，读写权限
    );
    BYTE* pMemory2 = pMemory+4;
    filsize_new = ntHeaders->OptionalHeader.SizeOfHeaders;
    memcpy(pMemory2, base, filsize_new);
    pMemory2 = pMemory2 + filsize_new;
    
    int numSection = ntHeaders->FileHeader.NumberOfSections;
    for (int i = 0; i < numSection; i++)
    {
        filsize_new += secHeader->SizeOfRawData;
        memcpy(pMemory2, secHeader->VirtualAddress + base, secHeader->SizeOfRawData);
        secHeader++;
        pMemory2 += secHeader->SizeOfRawData;
    }
    *(DWORD*)pMemory = filsize_new;
    return pMemory;
}
int writeFile(WCHAR* fpath,BYTE* data,int dlen)
{
    // 打开文件
    HANDLE hFile = CreateFileW(fpath,  // 文件路径
        GENERIC_WRITE,              // 访问权限：写入
        0,                          // 共享模式：无
        NULL,                       // 安全属性：默认
        CREATE_ALWAYS,              // 打开方式：总是创建新文件
        FILE_ATTRIBUTE_NORMAL,      // 文件属性：普通
        NULL);                      // 模板文件句柄：无

    if (hFile == INVALID_HANDLE_VALUE)
    {
        // 文件打开失败
        printf("Failed to open the file. Error code: %d\n", GetLastError());
        return 1;
    }

    // 写入数据
    DWORD bytesWritten = 0;
    if (!WriteFile(hFile, data, dlen, &bytesWritten, NULL))
    {
        // 写入数据失败
        printf("Failed to write data to the file. Error code: %d\n", GetLastError());
        CloseHandle(hFile);
        return 1;
    }

    // 关闭文件
    CloseHandle(hFile);

    // 写入完成
    printf("Data written to the file successfully.\n");

    return 0;
}
BYTE* readFile(WCHAR* fpath) {
    void* newFileData;
    // 打开文件
    HANDLE hFile = CreateFileW(
        fpath,  // 文件路径，根据实际情况进行修改
        GENERIC_READ,               // 访问模式，只读
        0,                          // 共享模式，不共享
        NULL,                       // 安全特性，使用默认值
        OPEN_EXISTING,              // 打开已存在的文件
        FILE_ATTRIBUTE_NORMAL,      // 文件属性，正常
        NULL                        // 模板文件句柄，不使用
    );
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("无法打开文件\n");
        return 1;
    }

    // 获取文件大小
    DWORD fileSize = GetFileSize(hFile, NULL);
    if (fileSize == INVALID_FILE_SIZE) {
        printf("无法获取文件大小\n");
        CloseHandle(hFile);
        return 1;
    }

    // 分配内存
    LPVOID pMemory = VirtualAlloc(
        NULL,                   // 指定分配的地址，在此使用 NULL 表示由系统选择
        fileSize,               // 分配的内存大小，与文件大小一致
        MEM_COMMIT,             // 内存分配类型，表示提交内存
        PAGE_READWRITE          // 内存页面属性，读写权限
    );
    if (pMemory == NULL) {
        printf("无法分配内存\n");
        CloseHandle(hFile);
        return 1;
    }

    // 读取文件内容到内存
    DWORD bytesRead;
    if (!ReadFile(
        hFile,                  // 文件句柄
        pMemory,                // 缓冲区地址，用于接收文件内容
        fileSize,               // 要读取的字节数，与文件大小一致
        &bytesRead,             // 实际读取的字节数
        NULL                    // 用于传递异步 I/O 句柄，不使用
    )) {
        printf("读取文件失败\n");
        VirtualFree(pMemory, 0, MEM_RELEASE);
        CloseHandle(hFile);
        return 1;
    }

    printf("成功读取 %lu 字节的文件内容到内存\n", bytesRead);

    newFileData = va2fa(pMemory, bytesRead);

    // 关闭文件和释放内存
    CloseHandle(hFile);
    VirtualFree(pMemory, 0, MEM_RELEASE);


    //下面是一个写入文件的操作

    return newFileData;
}

int main()
{
    //file_mem
    //file_fix
    WCHAR f1[] = L"/Code/normal/C/VisualStdio/Often/x64/Debug/apt/haha.va";
    WCHAR f2[] = L"/Code/normal/C/VisualStdio/Often/x64/Debug/apt/haha.fa";
    BYTE* data = readFile(f1);
    writeFile(f2, data + 4, *(DWORD*)(data));
    VirtualFree(data, 0, MEM_RELEASE);
}

```



# 读取pe文件到内存



```c
/**
 * 函数名称：peFileMapping
 * 函数功能：其实就是读取二进制文件,然后把内容dump出来
 * 输入参数：
 *   - 参数1：TEXT(文件路径)
 * 返回值：开辟的内容,内容是文件的dump
 * 函数的前提: 无
 */
BYTE* peFileMapping(TCHAR* szFileName)
{
    HANDLE hFile;
    DWORD dwFileSize, dwBytesRead;
    BYTE* lpBuffer = NULL;

    hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        wprintf(L"Failed to open file, error code: %d\n", GetLastError());
        return NULL;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize == INVALID_FILE_SIZE)
    {
        wprintf(L"Failed to get file size, error code: %d\n", GetLastError());
        CloseHandle(hFile);
        return NULL;
    }

    lpBuffer = GlobalAlloc(GMEM_FIXED, dwFileSize + 1024);
    if (lpBuffer == NULL)
    {
        wprintf(L"Failed to allocate memory for file content, error code: %d\n", GetLastError());
        CloseHandle(hFile);
        return NULL;
    }

    if (!ReadFile(hFile, lpBuffer, dwFileSize, &dwBytesRead, NULL))
    {
        wprintf(L"Failed to read file content, error code: %d\n", GetLastError());
        GlobalFree(lpBuffer);
        CloseHandle(hFile);
        return NULL;
    }

    // Add NULL terminator at the end of the buffer
    lpBuffer[dwBytesRead] = '\0';
    CloseHandle(hFile);
    return lpBuffer;

    //记得GlobalFree(lpBuffer);
}
```

