
enum <char> ObjType 
{
	TYPE_NULL               =  '0',
	TYPE_NONE               =  'N',
	TYPE_FALSE              =  'F',
	TYPE_TRUE               =  'T',
	TYPE_STOPITER           =  'S',
	TYPE_ELLIPSIS           =  '.',
	TYPE_INT                =  'i',
	TYPE_INT64              =  'I',
	TYPE_FLOAT              =  'f',
	TYPE_BINARY_FLOAT       =  'g',
	TYPE_COMPLEX            =  'x',
	TYPE_BINARY_COMPLEX     =  'y',
	TYPE_LONG               =  'l',
	TYPE_STRING             =  's',
	TYPE_INTERNED           =  't',
	TYPE_REF                =  'r',
	TYPE_TUPLE              =  '(',//0x28
	TYPE_LIST               =  '[',
	TYPE_DICT               =  '{',
	TYPE_CODE               =  'c',
	TYPE_UNICODE            =  'u',
	TYPE_UNKNOWN            =  '?',
	TYPE_SET                =  '<',
	TYPE_FROZENSET          =  '>',
	TYPE_ASCII              =  'a',
	TYPE_ASCII_INTERNED     =  'A',
	TYPE_SMALL_TUPLE        =  ')',//0x29
	TYPE_SHORT_ASCII        =  'z',
	TYPE_SHORT_ASCII_INTERNED =  'Z',
};



//字节码和名字的映射
enum <ubyte> OpCode 
{
	NULL  							=0,
	POP_TOP                   =  1,
	ROT_TWO                   =  2,
	ROT_THREE                 =  3,
	DUP_TOP                   =  4,
	DUP_TOP_TWO               =  5,
	ROT_FOUR                  =  6,
	NOP                       =  9,
	UNARY_POSITIVE           =  10,
	UNARY_NEGATIVE           =  11,
	UNARY_NOT                =  12,
	UNARY_INVERT             =  15,
	BINARY_MATRIX_MULTIPLY   =  16,
	INPLACE_MATRIX_MULTIPLY  =  17,
	BINARY_POWER             =  19,
	BINARY_MULTIPLY          =  20,
	BINARY_MODULO            =  22,
	BINARY_ADD               =  23,
	BINARY_SUBTRACT          =  24,
	BINARY_SUBSCR            =  25,
	BINARY_FLOOR_DIVIDE      =  26,
	BINARY_TRUE_DIVIDE       =  27,
	INPLACE_FLOOR_DIVIDE     =  28,
	INPLACE_TRUE_DIVIDE      =  29,
	GET_AITER                =  50,
	GET_ANEXT                =  51,
	BEFORE_ASYNC_WITH        =  52,
	BEGIN_FINALLY            =  53,
	END_ASYNC_FOR            =  54,
	INPLACE_ADD              =  55,
	INPLACE_SUBTRACT         =  56,
	INPLACE_MULTIPLY         =  57,
	INPLACE_MODULO           =  59,
	STORE_SUBSCR             =  60,
	DELETE_SUBSCR            =  61,
	BINARY_LSHIFT            =  62,
	BINARY_RSHIFT            =  63,
	BINARY_AND               =  64,
	BINARY_XOR               =  65,
	BINARY_OR                =  66,
	INPLACE_POWER            =  67,
	GET_ITER                 =  68,
	GET_YIELD_FROM_ITER      =  69,
	PRINT_EXPR               =  70,
	LOAD_BUILD_CLASS         =  71,
	YIELD_FROM               =  72,
	GET_AWAITABLE            =  73,
	INPLACE_LSHIFT           =  75,
	INPLACE_RSHIFT           =  76,
	INPLACE_AND              =  77,
	INPLACE_XOR              =  78,
	INPLACE_OR               =  79,
	WITH_CLEANUP_START       =  81,
	WITH_CLEANUP_FINISH      =  82,
	RETURN_VALUE             =  83,
	IMPORT_STAR              =  84,
	SETUP_ANNOTATIONS        =  85,
	YIELD_VALUE              =  86,
	POP_BLOCK                =  87,
	END_FINALLY              =  88,
	POP_EXCEPT               =  89,
	HAVE_ARGUMENT            =  90,
	STORE_NAME               =  90,
	DELETE_NAME              =  91,
	UNPACK_SEQUENCE          =  92,
	FOR_ITER                 =  93,
	UNPACK_EX                =  94,
	STORE_ATTR               =  95,
	DELETE_ATTR              =  96,
	STORE_GLOBAL             =  97,
	DELETE_GLOBAL            =  98,
	LOAD_CONST              =  100,
	LOAD_NAME               =  101,
	BUILD_TUPLE             =  102,
	BUILD_LIST              =  103,
	BUILD_SET               =  104,
	BUILD_MAP               =  105,
	LOAD_ATTR               =  106,
	COMPARE_OP              =  107,
	IMPORT_NAME             =  108,
	IMPORT_FROM             =  109,
	JUMP_FORWARD            =  110,
	JUMP_IF_FALSE_OR_POP    =  111,
	JUMP_IF_TRUE_OR_POP     =  112,
	JUMP_ABSOLUTE           =  113,
	POP_JUMP_IF_FALSE       =  114,
	POP_JUMP_IF_TRUE        =  115,
	LOAD_GLOBAL             =  116,
	SETUP_FINALLY           =  122,
	LOAD_FAST               =  124,
	STORE_FAST              =  125,
	DELETE_FAST             =  126,
	RAISE_VARARGS           =  130,
	CALL_FUNCTION           =  131,
	MAKE_FUNCTION           =  132,
	BUILD_SLICE             =  133,
	LOAD_CLOSURE            =  135,
	LOAD_DEREF              =  136,
	STORE_DEREF             =  137,
	DELETE_DEREF            =  138,
	CALL_FUNCTION_KW        =  141,
	CALL_FUNCTION_EX        =  142,
	SETUP_WITH              =  143,
	EXTENDED_ARG            =  144,
	LIST_APPEND             =  145,
	SET_ADD                 =  146,
	MAP_ADD                 =  147,
	LOAD_CLASSDEREF         =  148,
	BUILD_LIST_UNPACK       =  149,
	BUILD_MAP_UNPACK        =  150,
	BUILD_MAP_UNPACK_WITH_CALL =  151,
	BUILD_TUPLE_UNPACK      =  152,
	BUILD_SET_UNPACK        =  153,
	SETUP_ASYNC_WITH        =  154,
	FORMAT_VALUE            =  155,
	BUILD_CONST_KEY_MAP     =  156,
	BUILD_STRING            =  157,
	BUILD_TUPLE_UNPACK_WITH_CALL =  158,
	LOAD_METHOD             =  160,
	CALL_METHOD             =  161,
	CALL_FINALLY            =  162,
	POP_FINALLY             =  163,


};

//操作码参数的一些判定吧
//const int HAVE_ARGUMENT = 90;//STORE_NAME也是他
//const int EXTENDED_ARG = 144;//py2是143
struct Instruction 
{
	if (ReadUByte(FTell()) == 144) 
	{
		ubyte opcode_extend; 
		ubyte oparg;
	} 
	else 
	{
		ubyte opcode; 
		ubyte oparg;
	}
};



/*根据opcode返回它的名字*/
string Opcode2Opname(OpCode opcode)
{
	local string opname = EnumToString(opcode);
	return opname;
}
struct Code 
{
	ObjType type;
	if (type != TYPE_STRING) {
		Warning("code not in string type");
		Exit(1);
	}
	int32 n;
	local int remain = n;
	local int end = FTell() + n;

	while (remain > 0) 
   {
		Instruction inst[remain/2] <read=ReadInstruction,optimize=false>;
		remain = end - FTell();
	}
};

string ReadInstruction(Instruction &ins)
{
	string s;
	OpCode opcode = (OpCode)ins.opcode;
	string opname = Opcode2Opname(opcode);
	if (exists(ins.oparg)) //如果有参数
	{
		uint32 oparg = ins.oparg;//参数
		if (opname == "COMPARE_OP") 
		{
			string cmp_op;
			switch (oparg) 
			{
				case 0: 
					cmp_op = "<"; 
					break;
				case 1: 
					cmp_op = "<="; 
					break;
				case 2: 
					cmp_op = "=="; 
					break;
				case 3: 
					cmp_op = "!="; 
					break;
				case 4: 
					cmp_op = ">"; 
					break;
				case 5: 
					cmp_op = ">="; 
					break;
				case 6: 
					cmp_op = "in"; 
					break;
				case 7: 
					cmp_op = "not in"; 
					break;
				case 8: 
					cmp_op = "is"; 
					break;
				case 9: 
					cmp_op = "is not"; 
					break;
				case 10: 
					cmp_op = "exception match"; 
					break;
				case 11: 
					cmp_op = "BAD"; 
					break;
			}
			SPrintf(s, "%s (%s)", opname, cmp_op);

		} 
		else 
		{
			SPrintf(s, "%s %d", opname, oparg);
		}
	} 
	else 
	{
		s = opname;
	}
	return s;
}

struct LnoTab 
{
	ObjType type;
	if (type != TYPE_STRING) 
	{
		Warning("lnotab not in string type");
		//Exit(1);
	}
	int32 n;
	struct 
	{
		uchar bytecode_offset_diff;
		uchar line_diff;
	} pair[n/2];
};

// Python/marshal.c
typedef struct r_object 
{
	ObjType type;
	local ObjType type_org=type&0x7f;
	switch (type_org) 
	{
		case TYPE_NULL:
		case TYPE_NONE:
		case TYPE_STOPITER:
		case TYPE_ELLIPSIS:
		case TYPE_FALSE:
		case TYPE_TRUE:
			break;
		case TYPE_INT:
			int32 value;
			break;
		case TYPE_INT64:
			int64 value;
			break;
		case TYPE_LONG:
			int32 n;
			local int size = n<0?-n:n;
			int16 digit[size];
			break;
		case TYPE_FLOAT:
			ubyte n;
			char value[n];
			break;
		case TYPE_BINARY_FLOAT:
			double value;
			break;

		case TYPE_COMPLEX:
			ubyte nr;
			char real[nr];
			ubyte ni;
			char imag[ni];
			break;

		case TYPE_BINARY_COMPLEX:
			double real;
			double imag;
			break;
			
		case TYPE_INTERNED:
		case TYPE_STRING:
			int32 n;
			if (n)
				char str[n];
			break;

		case TYPE_REF :
			int32 index;
			break;
		case TYPE_SHORT_ASCII_INTERNED://后来添加
		case TYPE_SHORT_ASCII://后来添加
			ubyte n;
			if (n)
				char str[n];
			break;
		case TYPE_TUPLE:
			int32 n;
			if (n)
				struct r_object elements[n] <optimize=false>;
			break;
		case TYPE_SMALL_TUPLE:	//后来添加的
			ubyte  n;
			if (n)
				struct r_object elements[n] <optimize=false>;
			break;
		case TYPE_LIST:
			int32 n;
			if (n)
				struct r_object elements[n] <optimize=false>;
			break;
		case TYPE_DICT:
			while (1) 
			{
				struct r_object key;
				if (key.type == TYPE_NULL)
					break;
				struct r_object val;
			}
			break;
		case TYPE_SET:
		case TYPE_FROZENSET:
			int32 n;
			if (n)
				struct r_object elements[n] <optimize=false>;
			break;
		case TYPE_CODE:
			int32 co_argcount;
			int32 co_posonlyargcount; 
			int32 co_kwonlyargcount; 
			int32 co_nlocals; 
			int32 co_stacksize;  
			int32 co_flags;  
			Code code;
			struct r_object consts;
			struct r_object names;
			struct r_object varnames;
			struct r_object freevars;
			struct r_object cellvars;
			struct r_object filename;
			struct r_object name;
			int32 firstlineno;
			LnoTab lnotab;
			break;
		default:
			Warning("unknown type code");
			Printf("unknown type code: %X,(%d)\n",type,type);
			break;
			//Exit(1);
	} 
} r_object;

struct {
	int32 magic;
	char zeroPadding[4];
	char mtime[4];
	char flen[4];
	r_object data;
} file;
