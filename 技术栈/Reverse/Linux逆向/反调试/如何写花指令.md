# 如何写花指令

基于我现有的一点点intel语法,无法自由的在gcc下编译

编译选项

```
gcc main.c -masm=intel -o main.elf
```

基于互补条件的跳转

```
asm(
    ".intel_syntax noprefix;"
    "jnz $+5;;"
    "jz  $+3;"
    "push rax;"	//这里需要把一字节的指令push rax 修改为其它垃圾指令,比如0xE8
);
//上面的跳转始终会来到这里
for (idex = 0; idex < 16 && booklist[idex]; idex++)
{
	Arr[i]=Arr[i]^0x10;
}
```

基于eflag的永真跳转

```
asm(
    ".intel_syntax noprefix;"
    "stc;"
    "jc $+3;" //该指令占用2字节,下面的push rax占1字节
    "push rax;"	//这里需要把一字节的指令push rax 修改为其它垃圾指令,比如0xE8
);
bookname[idex] = ptr;//上面的跳转始终会来到这里
```

基于eflag的永真跳转

```
if (*(booklist[idex] + j) == '\n')
{
    asm(
        ".intel_syntax noprefix;"
        "clc;"
        "jnc $+3;" //83
        "push rax;"
    );
    *(booklist[idex] + j) = 0;
    break;
}
```

基于修改eip的跳转

```
for (j = 0; j < size; ++j)
{
    read(0, booklist[idex] + j, 1);
    asm(
        ".intel_syntax noprefix;"
        "call $+6;"
        "push rax;" //83
        "pop rax;"
        "add rax,9;"
        "push rax;"
        "ret;"
        "push rax;" //F3
    );
}
```