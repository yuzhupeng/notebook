# 进程角度

# 行为占用检测

一个进程不能被多个进程调试:

```c
__attribute((constructor)) void before_main()
{
	if (ptrace(PTRACE_TRACEME, 0, 0, 0) == -1) 
	{
		printf("Find Some One Dbg me  before_main\n");
		//abort();
	} 
	printf("Check All good\n");
	return ;
}
```

# 双进程调试

```c
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <sys/ptrace.h>
 #include <sys/wait.h>
 #include <sys/user.h>
 
 int main()
 {
     pid_t child_pid;
     int status, input;
     struct user_regs_struct regs;
 
     char *prog_name = "/bin/ls";// 被调试程序的路径
     char *const prog_argv[] = {"ls", "-l", NULL};// 被调试程序的命令行参数
 
     child_pid = fork();
 
     if (child_pid == -1)
     {
         printf("Failed to fork child process!\n");
         exit(1);
     }
     else if (child_pid == 0)//子进程
     {
/* 子进程执行被调试程序 */
         ptrace(PTRACE_TRACEME, 0, NULL, NULL);
         printf("Hello\n");
         exit(1);
     }
     else
     {
/* 父进程开始调试子进程 */
         wait(&status);
 
         ptrace(PTRACE_SETOPTIONS, child_pid, NULL, PTRACE_O_TRACEEXEC);
         ptrace(PTRACE_CONT, child_pid, NULL, NULL);
 
         while (1)
         {
             wait(&status);
             if (WIFEXITED(status))
             {
                 printf("\nChild process has exited!\n");
                 break;
             }
             ptrace(PTRACE_GETREGS, child_pid, NULL, &regs);
             printf("\nsyscall: %lld\n", regs.orig_rax);// 输出系统调用号码
             ptrace(PTRACE_SYSCALL, child_pid, NULL, NULL);
         }
     }
 
     return 0;
 }
 
```

```c

 struct user_regs_struct {
     unsigned long r15;
     unsigned long r14;
     unsigned long r13;
     unsigned long r12;
     unsigned long rbp;
     unsigned long rbx;
     unsigned long r11;
     unsigned long r10;
     unsigned long r9;
     unsigned long r8;
     unsigned long rax;
     unsigned long rcx;
     unsigned long rdx;
     unsigned long rsi;
     unsigned long rdi;
     unsigned long orig_rax;
     unsigned long rip;
     unsigned long cs;
     unsigned long eflags;
     unsigned long rsp;
     unsigned long ss;
     unsigned long fs_base;
     unsigned long gs_base;
     unsigned long ds;
     unsigned long es;
     unsigned long fs;
     unsigned long gs;
 };
 
```

在 Linux 系统中，用于等待子进程退出的 wait4 系统调用在父进程调用该系统调用时会被挂起，直到以下三种情况之一发生后才会返回：

1. 子进程已经退出，父进程可以通过 wait4 的返回值获取子进程的退出状态和资源使用情况。
2. 子进程因为接收到一个信号而停止或恢复执行，此时 wait4 会返回 -1 并设置 errno 为 EINTR。
3. wait4 调用被信号处理程序中断，此时 wait4 也会返回 -1 并设置

PTRACE_PEEKUSER: 请求可用于读取调试寄存器

PTRACE_POKEUSER: 设置调试寄存器

`PTRACE_PEEKUSER/PTRACE_POKEUSER` 请求一次只能获取/修改一个寄存器的值。

# 多进程守护

其实有个思路,也哈桑蛮容易实现的

就是是我们执行的主要进程是子进程

然后在main函数种,fork出子进程,父进程关闭自己

然后子进程慢慢运行

那么就达到了一个可以不让IDA反调试的一个目的

# 内嵌汇编实现ptrace

```
 #include<stdio.h>
 static __always_inline volatile long no_hacker()
 {
     int status =0;//定义返回值变量
//内联汇编代码，系统调用ptrace，把eax寄存器的值赋给status变量
 
     __asm__ volatile(
         "mov $0x0,%%ebx\n\t"
         "mov $0x0,%%ecx\n\t"
         "mov $0x0,%%edx\n\t"
         "mov $0x1a,%%eax\n\t"
         "int $0x80\n\t"
         :"=a"(status)
         :);
     return status;//这里把系统的调用的返回值作为no_hacke函数的返回值
 }
 int main()
 {
     if (no_hacker()==-1)
     {
         printf("don't trace me\n");
         return 1;
     }
     printf("no one trace me\n");
     return 0;
 }
```

# ptrace

ptrace使用场景：

1. 编写动态分析工具，如gdb,strace
2. 反追踪，一个进程只能被一个进程追踪(*注：一个进程能同时追踪多个进程*)，若此进程已被追踪，其他基于ptrace的追踪器将无法再追踪此进程，更进一步可以实现子母进程双线执行动态解密代码等更高级的反分析技术
3. 代码注入，往其他进程里注入代码。
4. 不退出进程，进行在线升级

## 函数介绍

```
 #include <sys/ptrace.h>
 long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);
```

一共有四个参数：

- `request`: 表示要执行的操作类型。//反调试会用到`PT_DENY_ATTACH`，调试会用到`PTRACE_ATTACH`
- `pid`: 要操作的目标进程ID
- `addr`: 要监控的目标内存地址
- `data`: 保存读取出或者要写入的数据

父进程控制子进程运行，检查和改变它的核心Image。

Ptrace主要用来实现断点调试。当进程被中止，通知父进程，进程的内存空间可以被读写，父进程可以选择是子进程继续执行，还是中止

request的不同参数决定了系统调用的功能

![Untitled](%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%208af94acc5b8c42ad8ac4423a8de3dbeb/Untitled.png)

init进程不可以使用此函数

返回值：

成功返回0。错误返回-1。errno被设置

错误：

![Untitled](%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%208af94acc5b8c42ad8ac4423a8de3dbeb/Untitled%201.png)

## 应用功能

PTRACE_TRACEME

```
 ptrace(PTRACE_TRACEME,0 ,0 ,0)
```

描述：本进程被其父进程所跟踪。其父进程应该希望跟踪子进程。

PTRACE_PEEKTEXT, PTRACE_PEEKDATA

```
 ptrace(PTRACE_PEEKTEXT, _in_ pid, _in_ addr, _out_ data)
 ptrace(PTRACE_PEEKDATA, _in_ pid, _in_ addr, _out_ data)
```

描述：从内存地址中读取一个字节，pid表示被跟踪的子进程，内存地址由addr给出，data为用户变量地址用于返回读到的数据。

在Linux（i386）中用户代码段与用户数据段重合所以读取代码段和数据段数据处理是一样的。

PTRACE_POKETEXT, PTRACE_POKEDATA

```
 ptrace(PTRACE_POKETEXT, pid, addr, data)
 ptrace(PTRACE_POKEDATA, pid, addr, data)
```

描述：往内存地址中写入一个字节。pid表示被跟踪的子进程，内存地址由addr给出，data为所要写入的数据。

PTRACE_PEEKUSR

```
 ptrace(PTRACE_PEEKUSR, pid, addr, data)
```

描述：从USER区域中读取一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为用户变量地址用于返回读到的数据。

USER结构为core文件的前面一部分，它描述了进程中止时的一些状态，如：寄存器值，代码、数据段大小，代码、数据段开始地址等。

在Linux（i386）中通过PTRACE_PEEKUSER和PTRACE_POKEUSR可以访问USER结构的数据有寄存器和调试寄存器。

PTRACE_POKEUSR

```
 ptrace(PTRACE_POKEUSR, pid, addr, data)
```

描述：往USER区域中写入一个字节，pid表示被跟踪的子进程，USER区域地址由addr给出，data为需写入的数据。

PTRACE_CONT

```
 ptrace(PTRACE_CONT, pid, 0, signal)
```

描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。

PTRACE_SYSCALL

```
 ptrace(PTRACE_SYS, pid, 0, signal)
```

描述：继续执行。pid表示被跟踪的子进程，signal为0则忽略引起调试进程中止的信号，若不为0则继续处理信号signal。

与PTRACE_CONT不同的是进行系统调用跟踪。在被跟踪进程继续运行直到调用系统调用开始或结束时，被跟踪进程被中止，并通知父进程。

PTRACE_KILL

```
  ptrace(PTRACE_DETACH，pid,  0,0)
```

描述：杀掉子进程，使它退出。pid表示被跟踪的子进程。

PTRACE_SINGLESTEP

```
 ptrace(PTRACE_KILL, pid, 0, signle)
```

描述：设置单步执行标志，单步执行一条指令。pid表示被跟踪的子进程。signal为0则忽略引起调试进程中止的信号，

若不为0则继续处理信号signal。当被跟踪进程单步执行完一个指令后，被跟踪进程被中止，并通知父进程。

PTRACE_ATTACH

```
 ptrace(PTRACE_ATTACH，pid, 0,0)
 wait(pid); //用于等待子进程?
```

描述：跟踪指定pid 进程。pid表示被跟踪进程。被跟踪进程将成为当前进程的子进程，并进入中止状态。

PTRACE_DETACH

```
  ptrace(PTRACE_DETACH，pid,  0,0)
```

描述：结束跟踪。 pid表示被跟踪的子进程。结束跟踪后被跟踪进程将继续执行。

PTRACE_GETREGS

```
 ptrace(PTRACE_GETREGS, pid, 0, data)
```

描述：读取寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有17个基本寄存器的值。

PTRACE_SETREGS

```
 ptrace(PTRACE_SETREGS, pid, 0, data)
```

描述：设置寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有17个基本寄存器的值。

PTRACE_GETFPREGS

```
 ptrace(PTRACE_GETFPREGS, pid, 0, data)
```

描述：读取浮点寄存器值，pid表示被跟踪的子进程，data为用户变量地址用于返回读到的数据。此功能将读取所有浮点协处理器387的所有寄存器的值。

PTRACE_SETFPREGS

```
 ptrace(PTRACE_SETREGS, pid, 0, data)
```

描述：设置浮点寄存器值，pid表示被跟踪的子进程，data为用户数据地址。此功能将设置所有浮点协处理器387的所有寄存器的值

```
 #include <sys/ptrace.h>
 int main(int argc, char *argv [])
 {
     if (ptrace(PTRACE_TRACEME, 0, 0, 0) == -1)
     {
         printf("Debugger detected\n");
         return 1;
     }
     printf("All good");
     return 0;
 }
//这里我们使用'PTRACE_TRACEME'来指明进程将被调试，在此种情况下其他参数会被忽略。
//如果已经存在调试器，那么这次ptrace调用会失败，返回-1。
```

基于调试状态的反调试

Linux  系统gdb等调试器，都是通过ptrace系统调用实现，ptrace系统调用有一个特性就是当前进程已经被追踪了，就不能被其他父进程追踪，

所以只要我们设计的反调试程序开头就先执行一次ptrace(PTRACE_TRACEME, 0, 0, 0)，

当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1，就无法调试了

```
 #include <sys/ptrace.h>
 #include <stdio.h>
 int main()
 {
     if (ptrace(PTRACE_TRACEME, 0, 0, 0) == -1)//这里就直接先执行了
     {
         printf("don't trace me!\n");
         return 1;
     }
     printf("no one trace me!\n");
     return 0;
 }
```

如何防它?

查看api调用,然后no掉它

# 符号表

## 取出符号表

网上说是,如果可能有ptrace函数的话,就查符号表或者api调用

```
# readelf -s q | grep ptrace
     41: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND ptrace@GLIBC_2.2.5
# readelf -S q | grep ptrace
 
# objdump -t q | grep ptrace
 0000000000000000       F *UND*  0000000000000000              ptrace@GLIBC_2.2.5
# objdump -T q | grep ptrace
 0000000000000000      DF *UND*  0000000000000000 (GLIBC_2.2.5) ptrace
#
 
```

但是😂我们可以通过删除符号表的选项，来隐藏对ptrace的调用，但只是针对.sysmtab表，不会去掉`.dynsym`

> 用strip删除符号,删除多态符号?
> 

strip 通过删除可执行文件中ELF头的 typchk段、符号表、字符串表、行号信息、调试段、注解段、重定位信息等来实现缩减程序体积的目的。

而被剪裁过的可执行文件不可进行还原。

**常用参数：**

![Untitled](%E8%BF%9B%E7%A8%8B%E8%A7%92%E5%BA%A6%208af94acc5b8c42ad8ac4423a8de3dbeb/Untitled%202.png)

注：使用注意】
 1.gcc 对于编译时已经进行深层优化的程序，使用strip命令可能会导致无法正常运行！

## 静态加载

也可以在链接阶段使用使用ld的`-s`和`-S`参数，使得连接器生成的输出文件时就不产生符号信息，-s`和`-S`的区别在于`-S`移除调试符号信息，而`-s移除所有符号信息。

我们也可以在GCC中通过`-Wl,-s`和`-Wl,-S`来移除符号信

```
 gcc -static -o q q.c
 strip q
 然后就查不到ptrace的符号了
```

惊讶的是,这样一编译,我的elf文件就变得特别大,

以前的文件特别简单,函数不吃过20个,一旦这样编译后,我们的文件就变得特别大,有很多的函数

然后符号表和多态符号表都没了,我的文件类型由原来的多态共享文件转变为可执行文件

在我的IDA上,是看不出来调用了ptrace函数的.系统函数直接被展开了

## 动态加载

由于静态elf在过于笨重,也就是可执行文件很大

如果我们使用动态加载技术，就可以回到动态加载库文件（文件很小），并且ptrace不会出现在符号表和动态符号表

但是动态加载函数的时候是需要使用字符串ptrace，所以你可以对字符串`ptrace`加密一下

动态加载是在运行的时加载库并且检索库函数地址

动态的load函数地址来隐藏ptrace，

比如LoadLibiary然后GetProcess

```
 #include<stdlib.h>
 #include<stdio.h>
 #include<sys/ptrace.h>
 #include<dlfcn.h>//Linux动态库的显式调用
 #include<string.h>
 
 int MyGdbCheck();
 int main(int argc, char **argv)
 {
     MyGdbCheck();
 }
 int MyGdbCheck()
 {
     void *handle;//定义句柄指针变量
     long (*lp_ptrace)(enum __ptrace_request request, pid_t pid);//定义函数指针变量
//获取包含'ptrace'的库的句柄
     handle = dlopen ("/lib/x86_64-linux-gnu/libc.so.6", RTLD_LAZY);
 
//对动态解析函数“ptrace”的引用,go变量存的是ptrace的地址
     lp_ptrace = dlsym(handle, "ptrace");
     if (lp_ptrace(PTRACE_TRACEME, 0) < 0)
     {
         puts("being traced");
         exit(1);
     }
     puts("not being traced");
//关闭句柄
     dlclose(handle);
     return 0;
 }
```

## 局部变量存储字符串

去除字符串的直接搜索

对于elf的话

```
 strings q | grep flag
```

是可以搜索字符串的

但是他的局限性，或者是IDA的局限性就是

如果你把字符串定位变量，那么他就搜索不到

```
 #include<stdlib.h>
 #include<stdio.h>
 #include<sys/ptrace.h>
 #include<dlfcn.h>//Linux动态库的显式调用
 #include<string.h>
 
 int MyGdbCheck();
 int main(int argc, char **argv)
 {
     MyGdbCheck();
 }
 int MyGdbCheck()
 {
     char funcName[]="ptrace";
     char Youlose[]="being traced";
     char YouSucc[]="not being traced";
     void *handle;//定义句柄指针变量
     long (*lp_ptrace)(enum __ptrace_request request, pid_t pid);//定义函数指针变量
//获取包含'ptrace'的库的句柄
     handle = dlopen ("/lib/x86_64-linux-gnu/libc.so.6", RTLD_LAZY);
 
//对动态解析函数“ptrace”的引用,go变量存的是ptrace的地址
 
     lp_ptrace = dlsym(handle, funcName);
     if (lp_ptrace(PTRACE_TRACEME, 0) < 0)
     {
         puts(Youlose);
         exit(1);
     }
     puts(YouSucc);
//关闭句柄
     dlclose(handle);
     return 0;
 }
```

比如上面那个例子就是实现了所有的字符串都用变量，于是你用IDA或者strings就搜索不到，

于是我在exe上做了系统的实验，关于字符串搜索的问题

```
 #include<stdlib.h>
 #include<stdio.h>
 #include<sys/ptrace.h>
 #include<dlfcn.h>//Linux动态库的显式调用
 #include<string.h>
 
 int MyGdbCheck();
 int main(int argc, char **argv)
 {
     MyGdbCheck();
 }
 int MyGdbCheck()
 {

     char Youlose[]="being traced";
     char YouSucc[]="not being traced";
     puts("ptrace");
     return 0;
 }
```