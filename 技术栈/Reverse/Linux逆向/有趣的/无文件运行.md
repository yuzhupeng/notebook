# 无文件运行

# 参考链接

[https://www.anquanke.com/post/id/168791](https://www.anquanke.com/post/id/168791)

[https://blog.csdn.net/Rong_Toa/article/details/109845832](https://blog.csdn.net/Rong_Toa/article/details/109845832)

其实这个参考链接讲的更多的是用8种语言的应用无文件执行elf

# C

```
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/syscall.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
 
 int main()
 {
     int fd;
     pid_t child;
     char buf[BUFSIZ] = "";
     ssize_t br;
 
     fd = syscall(SYS_memfd_create, "foofile", 0);
     if (fd == -1)
     {
         perror("memfd_create");
         exit(EXIT_FAILURE);
     }
 
     child = fork();
     if (child == 0)//子进程
     {
         dup2(fd, 1);//关闭1,复制一份fd给1,于是fd和1指向了相同的共享内存
         close(fd);//减少一次引用
         execlp("/bin/date", "/bin/date", NULL);//执行这句话
         perror("execlp date");
         exit(EXIT_FAILURE);
     }
     else if (child == -1)
     {
         perror("fork");
         exit(EXIT_FAILURE);
     }
 
//父进程
     waitpid(child, NULL, 0);//等待子进程结束
     lseek(fd, 0, SEEK_SET);
     br = read(fd, buf, BUFSIZ);
     if (br == -1)
     {
         perror("read");
         exit(EXIT_FAILURE);
     }
     buf[br] = 0;
     printf("child said: '%s'n", buf);
     exit(EXIT_SUCCESS);
     return 0;
 }
```

# 汇编

我们先来试着理解隐藏在字节数组背后的内容。

```
 push 57
 pop rax
 syscall
 test eax, eax
 jnz quit
```

首先我们需要运行`fork`，64位系统上对应的调用号为`57`，具体调用表可参考[此处链接](http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/)。

然后我们需要调用`setsid`（调用号为`112`）将子进程转换成父进程。

```
 push 112
 pop rax
 syscall
```

然后再次调用`fork`：

```
 push 57
 pop rax
 syscall
 test eax, eax
 jnz quit
```

然后再轻车熟路调用`execve()`：

```
; execve
 mov rdi, 0xcafebabecafebabe; filename
 mov rsi, 0xdeadbeefdeadbeef; argv
 xor rdx, rdx; envp
 push 0x3b
 pop rax
 syscall
 push -1
 pop rax
 ret
```

最后调用`exit()`（调用号为`60`）结束进程。

```
; exit
 quit:
 push 0
 pop rdi
 push 60
 pop rax
 syscall
```

# Python

```
 import ctypes
 import os
 
 elf_binary = open('./w','rb').read()# 我们要执行的文件
 fd = ctypes.CDLL(None).syscall(319,"",1)# 创建共享内存
 final_fd = open('/proc/self/fd/'+str(fd),'wb')# 往内存里面写入文件
 final_fd.write(elf_binary)
 final_fd.close()
 os.execl('/proc/self/fd/'+str(fd),'argv0','argv1')# 这里是直接执行文件描述符,而不是直接调用那个syscall
 print('father exit\n')
```

其中w,是我们当前文件要执行的内容

我感到疑惑的地方就是,父进程怎么返回