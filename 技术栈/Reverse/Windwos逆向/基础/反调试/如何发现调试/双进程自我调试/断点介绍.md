# 断点介绍

参考链接

[恶意样本分析手册——理论篇](http://blog.nsfocus.net/sample-analysis-manual-theory/)

# 软件断点

当我们在调试器中对代码的某一行设置断点时，调试器会把这里的本来指令的第一个字节保存起来，然后写入一条INT3指令。

因为INT3指令的机器码是0xCC，仅有一个字节，所以设置和取消断点时也只需要保存和恢复一个字节。

当CPU执行到INT3指令时，由于INT3指令的设计目的就是中断到调试器，

因此，CPU执行执行这条指令的过程也就是产生断点异常并转去执行异常处理的过程。

在跳转到处理历程之前，CPU会保存当前的执行上下文，包括段寄存器，程序指针寄存器等内容

在保护模式下，在保存当前执行上下文之后，cpu会从IDTR寄存器中获得IDT的地址，在IDT表中查询异常处理函数

在Windows系统中，INT 3异常处理函数是操作系统内核函数KiTrap03。

在调试器收到调试事件后，会根据调试事件数据结构中的程序指针，得到断点发生的位置，然后在自己的断点列表中寻找与其匹配的项。

如果能找到说明是自己设置的断点。如果找不到，则说明导致这个异常的INT 3指令不是自己放进去的。

会告诉用户：一个用户插入的断点被触发了。

在调试器下，我们很少看到动态替换到程序的INT 3指令。

大多数调试器的做法是调试前下断点

软件断点虽然使用方便，但是也有局限性：

- 属于代码类断点，即可以让CPU执行到代码段内的某个地址是停下来，不使用于数据段和I/O控件
- 对于ROM中执行的程序，无法动态增加软件断点。因为目标内存是只读的，无法动态写入断点指令。这时就需要使用硬件断点。
- 在中断向量表或中断描述表（IDT）没有准备好或遭破坏的情况下，这类断点是无法或不能正常工作的，比如系统刚刚启动时或IDT被病毒篡改后，这时只能用硬件级的调试工具

# 硬件断点

IA-32处理器定义了8个调试寄存器，分别称为DR0-DR7。

在32位模式下，他们都是32位的；在64位模式下，都是64位的。下面以32位的情况来介绍。

32位硬件断点

![https://cdn.nlark.com/yuque/0/2023/png/34008525/1681272719519-73fefe7e-795a-465e-b2e4-c96c3cc999d2.png](https://cdn.nlark.com/yuque/0/2023/png/34008525/1681272719519-73fefe7e-795a-465e-b2e4-c96c3cc999d2.png)

- 4个32位的调试地址寄存器（DR0-DR3），64位下是64位的 , 用于设置断点的地址，
- 1个32位调试控制寄存器（DR7），64位时，高32位保留未用, DR7保存了断点是否启用、断点类型和长度等信息。
- 1个32位调试状态寄存器（DR6），64位时，高32位保留未用,  DR6为调试异常产生后显示的一些信息
- DR4和DR5是保留的

通过以上寄存器可以最多设置4个断点，基本分工是DR0-DR3用来指定断点的内存（线性地址）或I/O地址。

DR7用来进一步定义断点的中断条件。

DR6的作用是当调试事件发生时，向调试器报告事件的详细信息，以供调试器判断发生的是何种事件

这7个寄存器里面，Dr7是最重要的寄存器, 

24位被划分成四组分别与四个调试地址寄存器相对应   

1), 

0 - 7 标志位 控制了 DR0 - DR3 寄存器指定的断点是否处于激活状态

G 和 L 域分别代表 global 和 local 范围

L0/G0 ~ L3/G3：控制Dr0~Dr3局部有效还是全局有效；

每次异常后，L局部位都被清零，G全局位不清零

![Untitled](%E6%96%AD%E7%82%B9%E4%BB%8B%E7%BB%8D%209bbd63a991d04f0b8d874e4c4963ac60/Untitled.png)

2), 

断点长度(LENx)：00(1字节)、01(2字节)、11(4字节) 是通过DR7的LEN控制

16 - 31 标志位指定断点的类型和长度

![Untitled](%E6%96%AD%E7%82%B9%E4%BB%8B%E7%BB%8D%209bbd63a991d04f0b8d874e4c4963ac60/Untitled%201.png)

3), 

断点类型(R/Wx)：00(执行断点)、01(写入断点)、11(访问断点)

![Untitled](%E6%96%AD%E7%82%B9%E4%BB%8B%E7%BB%8D%209bbd63a991d04f0b8d874e4c4963ac60/Untitled%202.png)

设置硬件断点需要的DR0-DR3很简单，就是下断点的地址，DR7寄存器很复杂，位段信息结构体如下：

![Untitled](%E6%96%AD%E7%82%B9%E4%BB%8B%E7%BB%8D%209bbd63a991d04f0b8d874e4c4963ac60/Untitled%203.png)

上图所示，保存DR0-DR3地址所指向位置的断点类型(RW0-RW3)与断点长度(LEN0-LEN3)，

4), 

状态描述如下:

姿态:

00：执行

01：写入

10：当向相应地址进行输入输出（即I/O读写）时中断

11：读写

长度

00：1字节

01：2字节

10：8字节长或未定义（其他处理器）

11：4字节

设置硬件执行断点时，长度只能为1(LEN0-LEN3设置为0时表示长度为1)

设置读写断点时，如果长度为1，地址不需要对齐，

如果长度为2，则地址必须是2的整数倍，

如果长度为4，则地址必须是4的整数倍。

我们在使用硬件断点的时候，就是要设置调试寄存器，

将断点的地址设置到DR0-DR3中，

断点的长度设置到DR7的LEN0-LEN3中，

将断点的类型设置到DR7的RW0-RW3中，

将是否启用断点设置到DR7的L0-L3中。

实现硬件断点，首先要获取当前线程环境

```
//获取线程环境
CONTEXT g_Context = { 0 };
g_Context.ContextFlags = CONTEXT_CONTROL;
GetThreadContext(hThread, &g_Context);
```

获取信息后,如果要修改

```
//设置当前环境
SetThreadContext(hThread, &g_Context);
```

```c
typedef struct _CONTEXT {
    DWORD ContextFlags;
    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;
    FLOATING_SAVE_AREA FloatSave;
    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;
    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;
    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              // MUST BE SANITIZED
    DWORD   EFlags;             // MUST BE SANITIZED
    DWORD   Esp;
    DWORD   SegSs;
    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];

} CONTEXT;
```

# 其它断点

**条件断点**

是一个带有条件表达式的普通INT3断点，是软件断点的一种，只有某些条件得到满足时这个断点才能中断执行程序。

对于频繁调用的API函数，仅当特定参数传给他时才中断程序执行，这种情况下，条件断点特别有用，它可以节省调试的时间

**内存断点**

改变内存分页的属性，如内存访问断点设为不可访问属性。由于分页粒度的限制，无法保证精度，

最小改变一页的属性，不过内存断点不改变指令，不会被自校验检测到，并且没有个数限制，同时可以对一整段内存下断。归属于硬件断点