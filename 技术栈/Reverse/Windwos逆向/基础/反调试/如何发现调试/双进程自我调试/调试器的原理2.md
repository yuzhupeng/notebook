# 调试器的原理2

[Debug Blocker反调试技术分析-安全客 - 安全资讯平台](https://www.anquanke.com/post/id/100115)

里面还有一个题目,晚点做一下

打七说,逆向工程核心原理那本书上有

# 基本原理

Ollydbg的断点功能是基于异常处理来实现的，

通过捕获程序执行过程中的异常信息来中断程序的执行流程。

Ollydbg常用的断点类型有三种：INT3断点，内存断点，硬件断点。

每种断点都是一种制造异常的方法，首先使程序在运行过程中产生错误，然后由Ollydbg的异常处理来接管，从而实现断点的功能。

1), **加载调试程序**

调试程序的第一步就是使用OllyDbg来加载程序，加载的过程是通过创建新进程来完成的。

OllyDbg通过CreateProcess以**调试**的方式开启新进程。

在创建调成程序前，OllyDbg需要进行一些必要的检查工作

2), **异常处理机制**

异常就是程序运行过程中产生的错误。

OllyDbg利用异常机制捕获调试程序在运行过程中产生的异常，对异常进行排查，从而实现断点功能，使程序暂停运行。

OllyDbg将异常处理过程放置在一个大消息循环中，捕获异常的流程如下：

- 进入消息循环
- 利用WaitForDebugEvent函数捕获异常信息，如果捕获失败，则回到循环起始处。
- 捕获到异常，率先由OllyDbg插件进行异常处理
- 检查是否为调试异常，如果不是，则继续执行程序，回到循环起始处
- 如果是调试异常，则进行相关检查，进入断点异常处理函数中。

如果检测INT3断点失败，则会开始内存断点的异常检查。内存断点的设置过程是通过修改内存属性来达到触发异常的目的的。

因此，内存断点的触发便是内存访问类错误。其流程如下：

- 得到线程信息
- 跳转到相应的异常处理分支
- 若得到线程信息，则根据线程信息的eip进行赋值，否则根据异常地址进行赋值
- 得到异常所处的模块的信息，并解析反汇编信息，以进行相关检查
- 若模块为自解压（SFX）模式，则进行相应的检查以及错误处理
- 检查内存断点是否在dll中，弹出提示窗口，并将断点去除
- 最后调整优先级并退出

硬件断点的捕获过程是由调试寄存器来完成的，因此OllyDbg没有捕获处理过程。

# int3

OllyDbg实现INT3断点的主要流程如下：

- 检查INT3断点是否在记录的断点信息表中
- 将INT3断点信息记录到表中
- 记录INT3断点处的机器码信息
- 将INT3断点处的机器码修改为0xCC
- 设置断点信息表

# **内存断点**

内存断点用来监控内存，它可以对内存数据的访问和写入进行监控。

内存断点的设置主要依靠两个API来完成：VirtualQuery和VirtualProtectEx。

通过VirtualQuery来获取原内存页的属性，以便于还原；

通过VirtualProtectEx修改内存页属性，以制造内存访问异常。

被调试的目标进程发生异常后，首先处理这个异常的是调试器。因此调试器可以成功捕获这个异常。内存断点的处理过程是由异常处理部分来完成。

# **硬件断点**

在寄存器中，有一些寄存器专门用于调试，称为调试寄存器，

调试寄存器一共有8个：Dr0-Dr7；对于Dr0-Dr3四个寄存器，作用是存放中断的地址，Dr4和Dr5一般不使用，保留，

Dr6和Dr7这两个寄存器的作用是用来记录Dr0-Dr3中下断的地址的属性，

比如：对这个401000是硬件读还是写，或者是执行；是对字节还是对字，或者是双字。

关于硬件断点的详细信息，请参阅断点部分的硬件断点知识

# **单步执行 StepIn**

当在调试器中选择“步过”某条指令时，程序自动在下一 条语句停下来，这其实也属于一种中断，而且可以说是最常用的一种形式了，

当我们需要对某段语句详细分析，想找出程序的执行流程和注册算法时必须要进行这一 步。

是80386以上的INTEL CPU中EFLAGS寄存器，其中的TF标志位表示单步中断。

当TF为1时，CPU执行完一条指令后会产生单步异常，进入异常处理程序后TF自动置0。

调试器通过处理这个单步异常实现对程序的中断控制。持续地把TF置1，程序就可以每执行一句中断一次，从而实现调试器的单步跟踪功能。

# 逐条执**执行**

StepOver：

StepOver即逐条语句执行，遇到函数调用时不进入函数内部，其实现方式如下：

- 通过调试符号获取当前指令对应的行信息，并保存该行的信息。
- 检查当前指令是否CALL指令。如果是，则在下一条指令设置一个断点，然后让被调试进程继续运行；如果不是，则设置TF位，开始CPU的单步执行，跳到4）。
- 处理断点异常时，恢复断点所在指令第一个字节的内容。然后获取当前指令对应的行信息

1）中保存的行信息进行比较，如果相同，跳到

2）；否则停止StepOver。处理单步执行异常时，获取当前指令对应的行信息，与①中保存的行信息进行比较。如果相同，跳到

3）；否则停止StepOver。

# 具体实现

[](https://github.com/redqx/mycode/tree/87532ad03fa2a8e5bbcb355942c4a43181a01708/Re/Antidbg/DebugBlocker)

利用在进程中创建进程，或者通过自调试创建两个进程。

其中一个为父进程，另一个为子进程。

两个进程都是同一个可执行文件只不过执行流程不一样。

然后通过在父进程中修复子进程，子进程修改自身的自修改手段达到反调试的目的。

使用CreateProcess()API创建进程时，

若选用了DEBUG_PROCESS|DEBUG_ONLY_THIS_PROCESS参数，

则创建出来的父子进程会形成调试器与被调试者的关系。

dwCreationFlags标识了影响新进程创建方式的标志：

**DEBUG_PROCESS：如果这个标志被设置，调用进程将被当作一个调试程序，并且新进程会被当作被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。**

**DEBUG_ONLY_THIS_PROCESS：如果这个标志被设置，调用进程将被当作一个调试程序，并且新进程会被当作被调试的进程。系统把被调试程序发生的所有调试事件通知给调试器。**

**上面2个不同点在于DEBUG_PROCESS会调试被调试进程以及它的所有子进程，而DEBUG_ONLY_THIS_PROCESS只调试被调试进程，不调试它的子进程。**

Debug Blocker拥有的以下几个特征

调试进程与被调试进程首先是一种父子关系

被调试进程不能再被其他进程调试

终止调试进程也会终止被调试进程

调试器会对被调试进程的代码运行情况产生持续影响，缺少调试进程的前提下，仅凭被调试进程无法正常运行。

被调试进程中发生的所有异常均由调试器处理。

此时调试器可以修改被调试者分支，也可以对被调试进程内部加密代码解密，或向寄存器、栈中存入某些特定值

至少有三个函数可以用来作为调试器附加到一个正在运行的进程上：

- kernel32!DebugActiveProcess()
- ntdll!DbgUiDebugActiveProcess()
- ntdll!NtDebugActiveProcess()

由于一次只能将一个调试器附加到一个进程上，附加到进程上的失败可能表明有另一个调试器存在