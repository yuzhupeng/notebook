# 异常和中断理解

# 异常分为3类

错误，

陷阱,

中止

根据异常发生时是否可以恢复执行，可以将异常分为三种类型，分别是错误异常，陷阱异常以及中止异常。

错误异常和陷阱异常一般都可以修复，并且在修复后程序可以恢复执行。

两者的不同之处在于，错误异常恢复执行时，是从引发异常的那条指令开始执行；而陷阱异常是从引发异常那条指令的下一条指令开始执行。

中止异常属于严重的错误，程序不可以再继续执行。

根据异常产生的原因，可以将异常分为硬件异常和软件异常。硬件异常即由CPU引发的异常。

软件异常即程序调用RaiseException函数引发的异常，C++的throw语句最终也是调用该函数来抛出异常的。软件异常的异常代码可以在调用RaiseException时由程序员任意指

# **中断**

中断和异常从产生的根源来看有着本质的区别，

但是系统（CPU和操作系统）是用统一的方式来响应和管理他们的

中断和异常处理的核心数据结构是中断描述符表（IDT）。当中断和异常发生时，CPU通过查找IDT表来定位处理例程的地址，然后转去执行该处理例程。

这个查找的过程是在CPU内部执行的。

通常，系统软件（操作系统和BIOS固件）在系统初始化阶段就准备好中断处理例程和IDT表，然后把IDT表的位置通过IDTR寄存器告诉CPU。

下面是IA-32 CPU相应中断和异常的全过程：

1. 将代码段寄存器CS和指令指针寄存器（EIP）的低16位压入堆栈
2. 将标志寄存器EFLAGS的低16位压入堆栈
3. 清除标志寄存器的IF标志，以禁止其他中断
4. 清除标志寄存器的TF，RF，AC标志
5. 使用向量号n作为索引，在IVT中找到对应的表项（n*4+IVT表基地址）
6. 将表项中的段地址和偏移地址分别装入CS和EIP寄存器中，并开始执行对应的代码
7. 中断例程总是以IRET指令结束。IRET指令会从堆栈中弹出前面保存的CS，IP和标志寄存器值，然后返回执行被中断的程序。